<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="PAT-甲级 做题笔记, HopenX">
    <meta name="description" content="PAT-Advanced Level 重点题目分类记录，对于夯实数据结构和算法基础有很重要的帮助">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>PAT-甲级 做题笔记 | HopenX</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/css/highlight/styles/vs2015.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"></head>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    <div>
                        
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/logo.png" class="logo-img" alt="LOGO">
                        
                        <span class="logo-span">HopenX</span>
                    </div>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HopenX</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/HopenX/hopenx.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #267871;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/HopenX/hopenx.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>



    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">PAT-甲级 做题笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #267871;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #267871;
    }

    #toc-content .is-active-link::before {
        background-color: #267871;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <style type="text/css">
    #articleContent a {
        color: #267871; !important;
    }

    #artDetail .post-cate a {
        color: #267871; !important;
    }

    blockquote {
        border-left: 5px solid #267871; !important;
    }

    #artDetail .reprint a {
        color: #267871; !important;
    }

    pre {
        background: #1d1d1d;
    }

</style>

<script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/PAT/">
                                <span class="chip bg-color">PAT</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                算法
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-02-06
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="PAT-甲级-做题笔记"><a href="#PAT-甲级-做题笔记" class="headerlink" title="PAT-甲级 做题笔记"></a>PAT-甲级 做题笔记</h1><p><img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://i.loli.net/2020/02/06/Y49WNI6DpA3hSKX.png" alt="甲级题目分类"></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>0000 <a href="#0000">做题 Tips 基本经验</a><br>1003 <a href="#1003">Emergency (Dijkstra 算法)</a><br>1004 <a href="#1004">Counting Leaves (计算叶节点数，DFS/BFS 树算法)</a><br>1007 <a href="#1007">Maximum Subsequence Sum(最大子序列和)</a><br>1010 <a href="#1010">Radix (进制转换/二分法)</a><br>1012 <a href="#1012">The Best Rank (应用问题，数据结构设计，多维度排序)</a><br>1013 <a href="#1013">Battle Over Cities (图的遍历，统计强连通分量的个数，DFS)</a><br>1014 <a href="#1014">Waiting in Line (队列应用，排队问题)</a><br>1015 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805495863296000" target="_blank" rel="noopener">Reversible Primes (进制转换+判断素数：可取用函数)</a><br>1016 <a href="#1016">Phone Bills (日期类计算)</a><br>1018 <a href="#1018">Public Bike Management (图最短路径 Dijkstra + DFS)</a><br>1020 <a href="#1020">Tree Traversals (已知后序和中序，转前序/层序)</a><br>1021 <a href="#1021">Deepest Root (求树中最长的路径，DFS，连通分量)</a><br>1040 <a href="#1040">Longest Symmetric String (求最长对称子串, DP)</a><br>1045 <a href="#1045">Favorite Color Stripe (最长不下降子序列, DP)</a><br>1068 <a href="#1068">Find More Coins (0-1 背包问题, DP)</a><br>1044 <a href="#1044">Shopping in Mars (特定值子序列和, 二分查找)</a><br>1085 <a href="#1085">Perfect Sequence (二分查找, upper_bound, 双指针)</a></p>
<hr>
<h2 id="0000-做题-Tips-基本经验"><a href="#0000-做题-Tips-基本经验" class="headerlink" title="0000 做题 Tips 基本经验"></a>0000 做题 Tips 基本经验<span id="0000"></span></h2><ol>
<li>最后千万别栽在头文件上，比如 reverse() 属于 &lt; algorithm&gt;</li>
<li><p>输出多行的时候，最后有一个多余的空行也没问题<br>比如使用 <code>cout &lt;&lt; a &lt;&lt; endl</code> 三次，样例输出：</p>
<pre><code> 3
 4
 5
</code></pre><p> 实际输出：最后有一个多余空行没关系（实际上是需要一个\n 或者 endl 才正确）</p>
<pre><code> 3
 4
 5
</code></pre></li>
<li>int 最大范围 $-2^{31}$=-2147483648 到 $2^{31}$-1=2147483647  (10 位数)</li>
</ol>
<hr>
<p><span id="1003"></span></p>
<h2 id="1003-Emergency-Dijkstra-算法"><a href="#1003-Emergency-Dijkstra-算法" class="headerlink" title="1003 Emergency (Dijkstra 算法)"></a>1003 Emergency (Dijkstra 算法)</h2><h3 id="1-题目大意"><a href="#1-题目大意" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>n个城市m条路，每个城市有救援小组，所有的边的边权已知。给定起点和终点，求从起点到终点的最短路径条数以及最短路径上的救援小组数目之和。如果有多条就输出点权（城市救援小组数目）最大的那个</p>
<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>用一遍Dijkstra算法～救援小组个数相当于点权，用Dijkstra求边权最小的最短路径的条数，以及这些最短路径中点权最大的值～dis[i]表示从出发点到i结点最短路径的路径长度，num[i]表示从出发点到i结点最短路径的条数，w[i]表示从出发点到i点救援队的数目之和～当判定dis[u] + e[u][v] &lt; dis[v]的时候，不仅仅要更新dis[v]，还要更新num[v] = num[u], w[v] = weight[v] + w[u]; 如果dis[u] + e[u][v] == dis[v]，还要更新num[v] += num[u]，而且判断一下是否权重w[v]更小，如果更小了就更新w[v] = weight[v] + w[u]</p>
<h3 id="3-个人代码"><a href="#3-个人代码" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">PTA-1003</a></p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

//Dijkstra 算法：单源最短路径
int n, m, c1, c2;
int e[510][510], weight[510], dis[510], num[510], w[510];
//边的邻接矩阵，每个点的权值，从出发点到i的距离，最短距离边数，最大权重和
const int Inf = 99999999;
bool visit[510];

int main(){
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; weight[i];
    }
    fill(e[0], e[0]+510*510, Inf);  //整个邻接矩阵填正无穷，默认不可达
    fill(dis, dis+510, Inf);
    int a,b,c;
    for (int j = 0; j &lt; m; ++j) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        e[a][b] = e[b][a] = c;  //一定要对称
    }

    dis[c1] = 0;
    num[c1] = 1;
    w[c1] = weight[c1];  //初始化

    for (int i = 0; i &lt; n; ++i) {    //每个点都要作为起始点 开始一遍
        int u = -1, min_d = Inf;        //每次循环重置

        //本次循环表示从 i 出发, i -&gt; j
        for (int j = 0; j &lt; n; ++j) {
            if(!visit[j] &amp;&amp; dis[j] &lt; min_d){   //找从本点出发的最小边
                u = j;
                min_d = dis[j];
            }
        }
        if(u == -1) break;
        visit[u] = true;

        //得到一条 i-&gt;u, 即 dis[], 用来更新最短路径
        //之前没更新的、在后续得到更新，达到最优
        for (int v = 0; v &lt; n; ++v) {
            if(!visit[v] &amp;&amp; e[u][v] != Inf){
                if(dis[u] + e[u][v] &lt; dis[v]){
                    dis[v] = dis[u] + e[u][v];
                    w[v] = w[u] + weight[v];
                    num[v] = num[u];
                } else if(dis[u] + e[u][v] == dis[v]){
                    num[v] += num[u];
                    if(w[v] &lt; w[u]+weight[v])
                        w[v] = w[u]+weight[v];   //携带尽可能多的人
                }
            }
        }
    }

    cout &lt;&lt; num[c2] &lt;&lt; &quot; &quot; &lt;&lt; w[c2];   //从出发点到c2
    return 0;
}
</code></pre>
<h3 id="4-学习要点"><a href="#4-学习要点" class="headerlink" title="4. 学习要点"></a>4. 学习要点</h3><blockquote>
<p>1.真正理解单源最短路径，每一次选择的 dis 都是相对于源点的最短路径<br>2.大数组要设为全局变量<br>3.外层循环 i：n 次循环，每次访问一个新点，保证 n 个点全访问到；内层循环 j：继续寻找还未访问的点，找 dis 最小的访问；内层循环 k：更新所有能够更新的 dis</p>
</blockquote>
<hr>
<p><span id="1004"></span></p>
<h2 id="1004-Counting-Leaves-dfs-bfs-树算法"><a href="#1004-Counting-Leaves-dfs-bfs-树算法" class="headerlink" title="1004 Counting Leaves (dfs/bfs 树算法)"></a>1004 Counting Leaves (dfs/bfs 树算法)</h2><h3 id="1-题目大意-1"><a href="#1-题目大意-1" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出一棵树，问每一层各有多少个叶子结点</p>
<h3 id="2-坑"><a href="#2-坑" class="headerlink" title="2. 坑"></a>2. 坑</h3><pre><code>list[tmp].lev = list[fa].lev + 1;  //出问题,不一定按照顺序输入
</code></pre><p>有可能先 03 后 01，fa 的 lev 还没确定，不能给孩子节点 +1</p>
<pre><code>3 2
03 1 02
01 1 03
</code></pre><h3 id="3-个人代码-1"><a href="#3-个人代码-1" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184" target="_blank" rel="noopener">PTA-1004</a></p>
<h3 id="4-正确方法"><a href="#4-正确方法" class="headerlink" title="4. 正确方法"></a>4. 正确方法</h3><pre><code class="lang-cpp">void dfs(int fa){
    for (auto &amp;ch : list[fa].v) {
        list[ch].lev = list[fa].lev + 1;
        dfs(ch);
    }
}
dfs(1);   //通过 DFS 一层层给叶子节点 lev+1
</code></pre>
<hr>
<p><span id="1007"></span></p>
<h2 id="1007-Maximum-Subsequence-Sum-最大子序列和"><a href="#1007-Maximum-Subsequence-Sum-最大子序列和" class="headerlink" title="1007 Maximum Subsequence Sum (最大子序列和)"></a>1007 Maximum Subsequence Sum (最大子序列和)</h2><h3 id="1-题目大意-2"><a href="#1-题目大意-2" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>求最大连续子序列和，输出最大的和以及这个子序列的开始值和结束值。如果所有数都小于0，那么认为最大的和为0，并且输出首尾元素</p>
<h3 id="2-分析-1"><a href="#2-分析-1" class="headerlink" title="2.分析"></a>2.分析</h3><p>本质上是<strong>动态规划</strong>的思想，数组为<code>vec[]</code>，设<code>dp[i]</code> 是以<code>vec[i]</code>结尾的子数组的最大和，对于元素<code>vec[i+1]</code>, 它有两种选择：<code>vec[i+1]</code>接着前面的子数组构成最大和; <code>vec[i+1]</code>自己单独构成子数组。则<code>dp[i+1] = max{dp[i]+vec[i+1],  vec[i+1]}</code></p>
<p>简化则用一个 temp_sum 和一个 temp_first 解决，真正最大和为 sum，起始点为 first 和 last，建立局部和全局的关系。如果 <code>temp_sum &lt; 0</code>, 说明目前这一段对后续的序列和已经没有加成作用，可以舍弃另立门户，令<code>temp_sum = 0</code></p>
<h3 id="3-个人代码-2"><a href="#3-个人代码-2" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><pre><code class="lang-cpp">//初始值设置容易坑：sum要为-1 才能开始
int sum=-1, temp_sum=0, first=0, last=k-1, temp_first=0;
for (int j = 0; j &lt; k; ++j) {
    temp_sum += a[j];
    if(temp_sum &lt; 0){
        temp_sum = 0;
        temp_first = j+1;   //本段已经可以舍弃，开始新一段
    } else if(temp_sum &gt; sum){
        sum = temp_sum;
        first = temp_first;
        last = j;
    }
}
if(sum &lt; 0) sum = 0;  //如果全负则为 0，根据题目要求不要漏情况
</code></pre>
<h3 id="4-类似题"><a href="#4-类似题" class="headerlink" title="4. 类似题"></a>4. 类似题</h3><p><a href="https://www.cnblogs.com/grandyang/p/4480780.html" target="_blank" rel="noopener">最长无重复子串</a></p>
<hr>
<p>)<span id="1010"></span></p>
<h2 id="1010-Radix-进制转换-二分法"><a href="#1010-Radix-进制转换-二分法" class="headerlink" title="1010 Radix (进制转换/二分法"></a>1010 Radix (进制转换/二分法</h2><h3 id="1-题目大意-3"><a href="#1-题目大意-3" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定两个相等数，已知一个数的进制，求另外一个数的进制（radix-&gt;基数）</p>
<h3 id="2-分析-2"><a href="#2-分析-2" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>通用函数<code>cal(string str, int radix)</code>把任意进制的数转换为 10 进制数<br>在使用搜索遍历，找到另一个数对应的进制</p>
<h3 id="3-个人代码-3"><a href="#3-个人代码-3" class="headerlink" title="3.个人代码"></a>3.个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536" target="_blank" rel="noopener">PTA-1010</a></p>
<p>转换函数</p>
<pre><code class="lang-cpp">long long cal(string str, long long radix){
    long long target=0, bak = 1;
    reverse(str.begin(), str.end());
    for (char c : str) {
        if(isdigit(c))
            target += (c - &#39;0&#39;) * bak;
        else
            target += (c - &#39;a&#39; + 10) * bak;
        bak *= radix;  //也可以使用&lt;cmath&gt;的 pow()函数
    }
    return target;
}
</code></pre>
<p>搜索函数</p>
<pre><code class="lang-cpp">long long find_radix(string str, long long tar){
    char c = *max_element(str.begin(), str.end());  //最大字母
    //进制至少比最大字母要大
    long long low = isdigit(c) ? c-&#39;0&#39; : c-&#39;a&#39;+10;
    low += 1;  //必须要加一,至少多1
    long long high = max(low, tar);  //进制最大不会大于目标 tar
    while (low &lt;= high){
        long long mid = (low+high)/2;
        long long tmp = cal(str, mid);
        if(tmp &lt; 0 || tmp &gt; tar) high = mid - 1;  //小于 0 也是进制太大
        else if(tmp == tar) return mid;
        else low = mid + 1;
    }
    return -1;
}
</code></pre>
<h3 id="4-学习要点-1"><a href="#4-学习要点-1" class="headerlink" title="4. 学习要点"></a>4. 学习要点</h3><blockquote>
<ol>
<li>进制转换这种大数字的乘法很容易溢出，必须要用 <code>long long</code></li>
<li>暴力搜索（从 2 到 ∞ 容易超时）最好用二分法，并且限定范围：最小是 <code>low</code> 至少是最大的那个字母+1，比如 fff 最少是 15+1=16 进制，最大是<code>high</code>不超过目标 <code>tar</code></li>
<li>可以使用反向迭代器 <code>it = n.rbegin(); it != n.rend()</code>代替<code>reverse()</code></li>
</ol>
</blockquote>
<hr>
<h2 id="1012-The-Best-Rank-数据结构设计-多维度排序"><a href="#1012-The-Best-Rank-数据结构设计-多维度排序" class="headerlink" title="1012 The Best Rank (数据结构设计/多维度排序)"></a>1012 The Best Rank (数据结构设计/多维度排序)<span id="1012"></span></h2><h3 id="1-题目大意-4"><a href="#1-题目大意-4" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>找出每个人自己最优势的科目，也就是单独排名最好的科目，优先级 A &gt; C &gt; M &gt; E</p>
<ul>
<li>Sample Input:<pre><code>5 6
310101 98 85 88
310102 70 95 88
310103 82 87 94
310104 91 91 91
310105 85 90 90
310101
310102
310103
310104
310105
999999
</code></pre></li>
<li>Sample Output:<pre><code>1 C
1 M
1 E
1 A
3 A
N/A
</code></pre></li>
</ul>
<h3 id="2-个人代码"><a href="#2-个人代码" class="headerlink" title="2. 个人代码"></a>2. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480" target="_blank" rel="noopener">PTA-1012</a></p>
<h3 id="3-学习要点"><a href="#3-学习要点" class="headerlink" title="3. 学习要点"></a>3. 学习要点</h3><p>数据结构设计</p>
<pre><code class="lang-cpp">struct node{
    //一定要用数组形式，避免过多变量 int c, m, e, c_r, m_r, e_r, a_r;
    int id, best;
    int score[4], rank[4];
}stu[2001];  //输入学生序列，非学号排序

int exist[1000000], flag=-1; //exist 至少 &gt;0, 顺便建立 id-输入序号 映射

//使用 flag 配置作用，避免写过多重复的 cmp 函数
bool cmp(node &amp;a, node &amp;b){ return a.score[flag] &gt; b.score[flag];}
</code></pre>
<p>输入后，利用<code>exist[stu[k].id] = k + 1; k++</code> 依次建立映射<br>输出时，利用<code>cin &gt;&gt; tmp; ex = exist[tmp]</code>和<code>stu[ex-1]</code>实现映射，无需 find<br>处理时，使用<code>sort(stu, stu+n, cmp)</code> 循环 <code>flag++</code>，实现分学科多次排序，确定 <code>rank[]</code></p>
<hr>
<p><span id="1013"></span></p>
<h2 id="1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）"><a href="#1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）" class="headerlink" title="1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）"></a>1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）</h2><h3 id="1-题目大意-5"><a href="#1-题目大意-5" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出n个城市之间有相互连接的m条道路，当删除一个城市和其连接的道路的时候，问其他几个剩余的城市至少要添加多少个路线，才能让它们重新变为连通图</p>
<h3 id="2-分析-3"><a href="#2-分析-3" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>n 连通分量，最少需要 n-1 条边相连，所以本题实质就是求「去除某点及其相连的边」后，剩余的「连通分量个数」是一个图算法，需要用图的遍历来解决 (DFS)</p>
<blockquote>
<p>求连通分量依据：一次 <code>dfs()</code>走到底，可以访问完一个连通分量</p>
</blockquote>
<p>数据结构：</p>
<blockquote>
<p>涉及图的遍历，要考虑 <code>visit[]</code>数组<br>图的路径存储，使用二维矩阵</p>
</blockquote>
<h3 id="3-个人代码-4"><a href="#3-个人代码-4" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">PTA-1013</a></p>
<pre><code class="lang-cpp">for (int i = 0; i &lt; k; ++i) {
        int cur, cnt=0;
        cin &gt;&gt; cur;
        fill(visited, visited+n, false);
        visited[cur] = true;  //相当于把本点去除
        for (int j = 1; j &lt;= n; ++j) {  //依次计算所有连通分量，而非从本点出发
            if(!visited[j]){
                dfs(j);
                cnt++;
            }
        }
        cout &lt;&lt; cnt-1 &lt;&lt; endl;
    }
</code></pre>
<pre><code class="lang-cpp">void dfs(int st){   //只用来 visit，不负责计数
    visited[st] = true;
    for (int i = 0; i &lt;= n; ++i)
        if(!visited[i] &amp;&amp; e[st][i]){   //未访问且有路
            dfs(i);
        }
}
</code></pre>
<hr>
<p><span id="1014"></span></p>
<h2 id="1014-Reversible-Primes（队列应用-排队问题"><a href="#1014-Reversible-Primes（队列应用-排队问题" class="headerlink" title="1014 Reversible Primes（队列应用 排队问题"></a>1014 Reversible Primes（队列应用 排队问题</h2><h3 id="1-题目大意-6"><a href="#1-题目大意-6" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>n个窗口，每个窗口可以排队m人。有k位用户需要服务，给出了每位用户需要的minute数，所有客户在8点开始服务，如果有窗口还没排满就入队，否则就在黄线外等候。如果有某一列有一个用户走了服务完毕了，黄线外的人就进来一个。如果同时就选窗口数小的。求q个人的服务结束时间。<br>如果一个客户在17:00以及以后还没有开始服务（此处不是结束服务是开始17:00）就不再服务输出sorry；如果这个服务已经开始了，无论时间多长都要等他服务完毕。</p>
<h3 id="2-学习要点"><a href="#2-学习要点" class="headerlink" title="2. 学习要点"></a>2. 学习要点</h3><p>面对此类题目，总想按照 timeline 每分每秒去决策，其实队列的问题用队列解决。</p>
<p>以每个窗口为单位设计结构体，<code>poptime</code> 用于刚入黄线的人决策，<code>endtime</code> 用于已经在队内的人是否会 sorry 决策，<code>q</code> 表示本队列内排队情况。</p>
<p>给定客户序列，则以每一个客户为循环单位<code>(index++)</code>，队列有一个进就会有一个出，每次变动一个单位，更新各个队列的<code>poptime endtime q</code>等变量。</p>
<pre><code class="lang-cpp">struct node {
    int poptime, endtime;  //队首的人出队（结束）的时间, 队尾的人结束的时间
    queue&lt;int&gt; q;
};

int index = 1;
    //第 1 步：n*m 个客户先抢占黄线内, 直接瞬间涌入，不存在选择
    for (int i = 1; i &lt;= cap; ++i) {    //看做行和列，先抢第一行
        for (int j = 1; j &lt;= n; ++j) {
            if(index &lt;= k){
                win[j].q.push(time[index]);
                if(win[j].endtime &gt;= 540)
                    sorry[index] = true;
                win[j].endtime += time[index];
                if(i == 1)  //对于第一行，出队时间即本队结束时间，做一个初始化
                    win[j].poptime = win[j].endtime;
                res[index] = win[j].endtime;  //刚进来的，自己是队尾，队伍结束就是自己结束
                index++;
            }
        }
    }

    //第 2 步：后续的客户
    while (index &lt;= k){   //while一次循环表示一个客户的选择
        int temp_min = win[1].poptime, temp_win = 1;  //初始化
        for (int i = 2; i &lt;= n; ++i) {   //找最早出队的
            if(win[i].poptime &lt; temp_min){
                temp_win = i;
                temp_min = win[i].poptime;
            }
        }
        win[temp_win].q.pop();
        win[temp_win].q.push(time[index]);
        win[temp_win].poptime += win[temp_win].q.front(); //更新：最前面那个人完成的时间就是出队时间
        if(win[temp_win].endtime &gt;= 540)  //endtime 还未更新，是看的前一个人的完成时间，是否超时
            sorry[index] = true;
        win[temp_win].endtime += time[index];  //更新：刚进来的这个人的完成时间就是本队的完成时间
        res[index] = win[temp_win].endtime;
        index++;
    }
</code></pre>
<hr>
<p><span id="1016"></span></p>
<h2 id="1016-Phone-Bills（日期类计算"><a href="#1016-Phone-Bills（日期类计算" class="headerlink" title="1016 Phone Bills（日期类计算"></a>1016 Phone Bills（日期类计算</h2><h3 id="1-题目大意-7"><a href="#1-题目大意-7" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定固定格式的日期<code>mm:dd:hh:mm</code>计算各个时间的差值，以及每个时间段有不同的费率，计算总的账单费用。</p>
<h3 id="2-学习要点-1"><a href="#2-学习要点-1" class="headerlink" title="2. 学习要点"></a>2. 学习要点</h3><p>1.数据结构设计<br>因为输入是给定一个个 call 序列，所以便于存储，也以每个 call 为单位，统一放在一个数组里，按照名字、时间排序，计算的时候，只要考虑 i 和 i-1 前后两个元素是否有同一个 name 以及 status 一个为 0 一个为 1 即可。</p>
<pre><code class="lang-cpp">struct node {
    string name;
    int status, month, time, day, hour, minute;
};

bool cmp(node a, node b) {
    return a.name != b.name ? a.name &lt; b.name : a.time &lt; b.time;
}
</code></pre>
<p>2.日期差值计算<br>直接”01:05:02:24“-”01:04:23:59“ 难以计算，每个小时还有不同的费率，所以 <strong>统一从本月 0 天 0 点开始计算</strong>，以<code>dd:hh:mm</code>格式再相减即可，隔天的情况则加上这一整天</p>
<pre><code class="lang-cpp">double billFromZero(node call, int *rate) {
    double total;
    total = rate[call.hour];  //本小时的费用
    total += call.minute + rate[24] * 60 * call.day;  //从本月第 0 天到今天
    for (int i = 0; i &lt; call.hour; i++)
        total += rate[i] * 60;  //本天内 0 点到现在累加
    return total / 100.0;
}
</code></pre>
<hr>
<h2 id="1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）"><a href="#1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）" class="headerlink" title="1018 Public Bike Management（图最短路径 Dijkstra + DFS）"></a>1018 Public Bike Management（图最短路径 Dijkstra + DFS）<span id="1018"></span></h2><p>图例经过 Dijkstra 之后的结果</p>
<pre><code class="lang-cpp">dis[1] = 1      pre[1] = {0}
dis[2] = 1      pre[2] = {0}
dis[3] = 2      pre[3] = {1, 2}
</code></pre>
<hr>
<p><span id="1020"></span></p>
<h2 id="1020-Tree-Traversals-已知后序和中序，转前序-层序"><a href="#1020-Tree-Traversals-已知后序和中序，转前序-层序" class="headerlink" title="1020 Tree Traversals (已知后序和中序，转前序/层序)"></a>1020 Tree Traversals (已知后序和中序，转前序/层序)</h2><h3 id="1-输入格式"><a href="#1-输入格式" class="headerlink" title="1. 输入格式"></a>1. 输入格式</h3><pre><code>7
2 3 1 5 7 6 4
1 2 3 4 5 6 7
</code></pre><h3 id="2-分析-4"><a href="#2-分析-4" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>和手动模拟差不多，找到根节点 (pre 的第一个，post 的最后一个) -&gt; 找到左右两段的端点，分别作为左右子树 -&gt; 递归重复。关键在于递归的写法，端点的寻找。</p>
<h3 id="3-个人代码-5"><a href="#3-个人代码-5" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><code>level</code> 的作用即按照 <code>index</code> 存储，利用 2n+1 2n+2 的公式可以定位左右孩子，而索引的顺序恰好是层序遍历的顺序（具体第几层不知道）<br>转为前序遍历，只需在 pre 递归前打印 root 即可</p>
<pre><code class="lang-cpp">vector&lt;int&gt; in, post, level(100000, -1);

void pre(int root, int start, int end, int index){  
    //start end 都是相对于中序序列, 但是 root 是相对于 post 序列的！
    if(start &gt; end) return;
    level[index] = post[root];
    int i = start;
    while (i &lt; end &amp;&amp; in[i] != post[root]) i++;  //找到中序 in 序列中的根节点
    int left_size = i-start, right_size = end-i;
    pre(root-right_size-1, start, i-1, index*2+1);  //此 root 即为左孩子节点，可以确定为 index*2+1
    pre(root-1, i+1, end, index*2+2);
    //找到根节点 i，左子树 start ~ i-1, 右子树 i+1 ~ end
}
pre(n-1, 0, n-1, 0);
</code></pre>
<h3 id="4-类题"><a href="#4-类题" class="headerlink" title="4. 类题"></a>4. 类题</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024" target="_blank" rel="noopener">PTA-1086</a>（已知前序和中序遍历，求后序遍历）<br>给出用栈进行中序遍历的过程，求后序遍历。有一个隐含条件，push 的顺序即为前序遍历，相对于已知 pre 和 in，求 post，同样找 root, start, end 即可。</p>
<hr>
<p><span id="1021"></span></p>
<h2 id="1021-Deepest-Root-求树中最长的路径，DFS，连通分量"><a href="#1021-Deepest-Root-求树中最长的路径，DFS，连通分量" class="headerlink" title="1021 Deepest Root (求树中最长的路径，DFS，连通分量)"></a>1021 Deepest Root (求树中最长的路径，DFS，连通分量)</h2><h3 id="1-题目大意-8"><a href="#1-题目大意-8" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出n个结点（1~n）之间的n条边，问是否能构成一棵树，如果不能构成则输出它有的连通分量个数；如果能构成一棵树，输出能构成最深的树的高度时，树的根结点。如果有多个，按照从小到大输出。</p>
<h3 id="2-分析-5"><a href="#2-分析-5" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>连通分量的个数：基本套路，一次 DFS 走完一个连通分量，统计循环中 DFS 开启的次数即可<br>本题关键在于，两次 DFS 即可求出所有最远端点（即所有最长路径中的所有端点）如果是一棵树的话，线段无非是两个端点，第一次 DFS 能找到一端，在这些最远端点中（可能有多个同样最远的，可能只有一个最远的）随便选一个作为起点，再来一次 DFS，即可找到另一端的最远端点。</p>
<h3 id="3-个人代码-6"><a href="#3-个人代码-6" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856" target="_blank" rel="noopener">PTA-1003</a></p>
<pre><code class="lang-cpp">void dfs(int node, int height) {
    if(height &gt; maxheight) {
        temp.clear();
        temp.push_back(node);
        maxheight = height;
    } else if(height == maxheight){
        temp.push_back(node);
    }
    visit[node] = true;
    for(int i = 0; i &lt; v[node].size(); i++) {
        if(visit[v[node][i]] == false)
            dfs(v[node][i], height + 1);
    }
</code></pre>
<h3 id="4-做题-Tips"><a href="#4-做题-Tips" class="headerlink" title="4. 做题 Tips"></a>4. 做题 Tips</h3><ol>
<li>本题不用考虑权重，所以无需开一个二维数组用邻接矩阵存储<br><code>e[10010][10010]; e[a]=e[b]=weight;</code><br>只需使用邻接表，把和自己直接相连的点存起来即可<br><code>v[node][i]; resize(n+1);</code><br><br></li>
<li>DFS 基本套路<pre><code class="lang-cpp"> dfs(int node, ...){   //遍历过程中顺带做其它操作
     visit[node] = true;
     for 与本点直接相连的 i:
         if(!visit[i])
             dfs(i, ...)
 }
</code></pre>
</li>
</ol>
<hr>
<p><span id="1102"></span></p>
<h2 id="1102-Invert-a-Binary-Tree-翻转二叉树"><a href="#1102-Invert-a-Binary-Tree-翻转二叉树" class="headerlink" title="1102 Invert a Binary Tree (翻转二叉树)"></a>1102 Invert a Binary Tree (翻转二叉树)</h2><h3 id="1-题目大意-9"><a href="#1-题目大意-9" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定一棵二叉树，先翻转好，输出层序遍历和中序遍历</p>
<h3 id="2-分析-6"><a href="#2-分析-6" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>可以写一个 invert 函数，交换本节点左右元素，然后对左右孩子递归即可。</p>
<pre><code class="lang-cpp">struct node{
    int left=-1, right=-1;  //-1 表示 NULL
};

void invert(int r){
    int a = v[r].left, b = v[r].right;
    if(a == -1 &amp;&amp; b == -1)
        return;
    v[r].left = b;
    v[r].right = a;
    if(v[r].left != -1) invert(v[r].left);
    if(v[r].right != -1) invert(v[r].right);
}
</code></pre>
<p>也可以不用写，正常遍历即可，只是先遍历右孩子，再遍历左孩子即可。</p>
<pre><code class="lang-cpp">//层序遍历标准模式：
void level(int r){
    queue&lt;int&gt; q;
    q.push(r);
    while (!q.empty()){
        r = q.front();
        q.pop();
        // if(q.empty()) break;
        le_ans.push_back(r);
        if(v[r].left != -1) q.push(v[r].left);
        if(v[r].right != -1) q.push(v[r].right);
    }
}
</code></pre>
<h3 id="3-坑点："><a href="#3-坑点：" class="headerlink" title="3. 坑点："></a>3. 坑点：</h3><ol>
<li>一般的题，都要考虑元素可能有重复，可能不按顺序。本题使用    <code>mark</code>数组确定<code>root</code>是最好的方式</li>
<li><code>queue</code>和一般的<code>vector</code>有本质的不同，不能用迭代器遍历，不能索引，只能通过<code>front(), back()</code>访问。<code>quque</code>进行<code>pop(),front()</code>等操作时，一定要检查<code>q.empty()</code></li>
<li>当<code>queue</code>中只有一个元素时，<code>pop()</code>后，在访问<code>front()</code>可能会出现异常数字</li>
</ol>
<hr>
<p><span id="1040"></span></p>
<h2 id="1040-Longest-Symmetric-String-求最长对称子串-DP"><a href="#1040-Longest-Symmetric-String-求最长对称子串-DP" class="headerlink" title="1040 Longest Symmetric String (求最长对称子串 DP)"></a>1040 Longest Symmetric String (求最长对称子串 DP)</h2><h3 id="1-题目大意-10"><a href="#1-题目大意-10" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定一个字符串，找到最长的、对称的子串，输出长度<br>比如<code>Is PAT&amp;TAP symmetric?</code> 输出 11, 即<code>s PAT&amp;TAP s</code>的长度</p>
<h3 id="2-分析-7"><a href="#2-分析-7" class="headerlink" title="2. 分析"></a>2. 分析</h3><ol>
<li><p>基本递归的思路，大问题拆成小问题，拆成一个已知条件下的具体问题。对于 子串/子序列 问题，要么用 <code>dp[i][j]</code>表示 i 和 j 的子串，要么用 <code>dp[i]</code>表示 0 到 i 之间的子串.</p>
</li>
<li><p>本题要求每一对<code>dp[i][j]</code>就要已知<code>dp[i+1][j-1]</code>, 再根据<code>str[i]</code>和<code>str[j]</code>来判断本段是否对称, 复杂问题被简化, 逐层逐层抛弃.</p>
</li>
<li><p>dp 的另外一个关键就在于初始化, 本题将所有<code>dp[i][i]</code>和相邻相等的所有<code>dp[i][i-1]</code>赋值为 1</p>
</li>
<li><p>本题一个难点在于, 普通的 dp 都可以从序列开头递归即可, 本题要根据子串的长度, 从短到长进行循环, 从中沉淀出最长的 length</p>
</li>
</ol>
<h3 id="3-个人代码-7"><a href="#3-个人代码-7" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344" target="_blank" rel="noopener">PTA-1040</a></p>
<pre><code class="lang-c++">for (int L = 3; L &lt;= len; ++L) {   //线段长度由小到大
        for (int i = 0; i &lt; len - L + 1; ++i) {  //能够到达的最右端点
            int j = i + L - 1;  //本次 i 对应的右端点 j
            if(str[i] == str[j] &amp;&amp; dp[i+1][j-1]){  //更新dp
                dp[i][j] = 1;
                ans = L;
            }
        }
    }
</code></pre>
<hr>
<p><span id="1045"></span></p>
<h2 id="1045-Favorite-Color-Stripe-最长不下降子序列-DP"><a href="#1045-Favorite-Color-Stripe-最长不下降子序列-DP" class="headerlink" title="1045 Favorite Color Stripe (最长不下降子序列 DP)"></a>1045 Favorite Color Stripe (最长不下降子序列 DP)</h2><h3 id="1-题目大意-11"><a href="#1-题目大意-11" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出m中颜色作为喜欢的颜色（同时也给出顺序），然后给出一串长度为L的颜色序列，现在要去掉这个序列中的不喜欢的颜色，然后求剩下序列的一个子序列，使得这个子序列表示的颜色顺序符合自己喜欢的颜色的顺序，不一定要所有喜欢的颜色都出现。<br>1 - N 表示 N 种颜色, 比如给出 2 3 1 5 6 表示自己喜欢的颜色序列</p>
<h3 id="2-分析-8"><a href="#2-分析-8" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>在原串中要找出符合 2 3 1 5 6 顺序的所有子串, 可能需要多层循环遍历, 还要用额外数组 tmp 临时记录, 数据难以比较和判断, 很麻烦. 所以考虑转化成有序数组, 一一对应成 1 2 3 4 5, 通过比大小即可判断, 等价于转化成一个<strong>最长不下降子序列</strong>问题.</p>
<p>维护单调数组 dp, <code>dp[i]</code>表示从 0 - i 最长不下降子序列的长度, 可以 DP 的精髓就在于, 本位置 i 对应的<code>dp[i]</code>可以由前面的<code>dp[0]</code> — <code>dp[i-1]</code> 直接推出.</p>
<p>举例:</p>
<pre><code>i  2 1 5 3 6 4 8 9 7
dp 1 1 2 2 3 3 4 5 4
j  2 1 5 3 6 4 8 9 7
</code></pre><p>此过程中沉淀出的 maxn 就是 5</p>
<h3 id="3-个人代码-8"><a href="#3-个人代码-8" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><pre><code class="lang-c++">int book[201], a[10001], dp[10001];
//dp[i]内存储的是, 从 0 到 i 为止最长的长度, 与 book 无关

int main(){
    int n, m, l, tmp, maxn = -1;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= m; ++i) {  //颜色为 1-n 将颜色序列映射为 idx 递增序列
        cin &gt;&gt; tmp;
        book[tmp] = i;
    }
    cin &gt;&gt; l;
    int num = 0;
    for (int i = 0; i &lt; l; ++i) {  //关键一步，把所有颜色转化为序号，依次存入 a 中
        cin &gt;&gt; tmp;
        if(book[tmp] &gt;= 1){
            a[num++] = book[tmp];  //a 存储 idx
        }
    }
    for (int i = 0; i &lt; num; ++i) {   //不喜欢的颜色直接忽略了,不计入考察范围
        dp[i] = 1;   //每次初始赋值为 1, 检查 0-i
        for (int j = 0; j &lt; i; ++j) {
            if(a[i] &gt;= a[j]){   //以 a 为评判标准, 大于等于就能做下一步
                dp[i] = max(dp[i], dp[j]+1);
                //核心思想，已知0 ~ i-1 的最大值，新来的 i 最多比0 ~ i-1 多 1
            }
        }
        maxn = max(maxn, dp[i]);
    }
    cout &lt;&lt; maxn;
    return 0;
}
</code></pre>
<hr>
<p><span id="1068"></span></p>
<h2 id="1068-Find-More-Coins-01-背包问题-DP"><a href="#1068-Find-More-Coins-01-背包问题-DP" class="headerlink" title="1068 Find More Coins (01 背包问题 DP)"></a>1068 Find More Coins (01 背包问题 DP)</h2><h3 id="1-题目大意-12"><a href="#1-题目大意-12" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>用n个硬币买价值为m的东西，输出使用方案，使得正好几个硬币加起来价值为m。从小到大排列，输出最小的那个排列方案</p>
<h3 id="2-尝试-DFS"><a href="#2-尝试-DFS" class="headerlink" title="2. 尝试(DFS)"></a>2. 尝试(DFS)</h3><p>本题可以采用递归方案, DFS 递归到底, 直到刚好<code>target==0</code>即可, 类似于二叉树的寻找路径和. 但是某个测试点会超时.</p>
<p>核心代码(DFS 递归):</p>
<pre><code class="lang-c++">bool sear(int st, int target){   //搜索 st ~ n, 每次从 st 搜到末位
    if(0 == target)
        return true;
    for (int i = st; i &lt; n; ++i) {
        if(target &lt; a[i])   //后面的面额只会越来越大,不用搜了(剪枝)
            return false;
        tmp.push_back(a[i]);
        if (sear(i+1, target-a[i]))  //target减去当前,大目标拆成小目标
            return true;   //找到一个为 true 就不用再搜了,返回
        else tmp.pop_back();  //sear()==false 表示走不通, pop出来换下一个
    }
    return false;
}

sort(a, a+n);  //从小到大排序, 便于输出最小的方案
if(a[0] &gt; m){ printf(&quot;No Solution\n&quot;); return 0; } //面额太大,付不了小钱

for (int i = 0; i &lt; n; ++i) {  //逐个作为起点进行搜索
    tmp.clear();
    if(sear(i, m))
        break;
}
</code></pre>
<h3 id="3-0-1背包问题-DP"><a href="#3-0-1背包问题-DP" class="headerlink" title="3. 0-1背包问题(DP)"></a>3. 0-1背包问题(DP)</h3><p>给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi 。</p>
<p>问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？<br>DP 的题还是要用 DP 来做, 关键在于搞清楚每一个数组的作用</p>
<p>🎒背包问题的经典转移公式</p>
<pre><code class="lang-c++">if(j &gt;= w[i])
    dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]);
else
    dp[i][j] = dp[i-1][j];  

//面对这个 i 物品, 不拿(或装不下), 就等同于 i-1 的情况
</code></pre>
<p><code>dp[i][j]</code> 表示 在面对第 i 件物品，且背包容量为 j 时所能获得的最大价值<br><code>dp[i-1][j-w[i]]+v[i]</code>则是容量空出<code>w[i]</code>的情况下( i-1表示回溯一个序号), 装入<code>v[i]</code>所能得到的价值.</p>
<h3 id="4-正解-DP"><a href="#4-正解-DP" class="headerlink" title="4. 正解(DP)"></a>4. 正解(DP)</h3><pre><code>8 9
5 9 8 7 2 3 4 1
</code></pre><pre><code>1 3 5
</code></pre><pre><code class="lang-c++">int dp[101], choice[10001][101], w[10001];
//dp[j] 表示容量为 j 的时候, 最多能装多少钱数; w为每个硬币的面额
//choice[i][j]=true 表示总目标钱数为 j 时, i 可以作为一个选择
</code></pre>
<p>本题不是求最大价值, 只要求刚好装满, 只需要加一个判断<code>if(dp[m] != m)</code>, 然后以 m 为目标, 添加所有 choice 筛选的 [<strong>总目标钱数为 m 时, 可以作为一个选择</strong>] 的序列</p>
<p>本题的判断精髓就在这一句<code>if(dp[j] &lt;= dp[j-w[i]] + w[i])</code> 含义就是, 选择 w[i] 之后, 也能凑得和<code>dp[j]</code>之前 <strong>一样的, 甚至更多的</strong> 钱数.</p>
<p>本题实际发挥作用的时候, 小于号<code>&lt;</code>实际发挥的作用就是初始化, 让<code>dp[j]</code>从0变成一个数值, 比如<code>dp[9]=9</code>, 9 的面额直接满足; 等于号<code>=</code>实际发挥的作用就是寻找新的路径, 更新<code>choice[i][j]</code> 让<code>1 3 5</code>也组成进来.</p>
<p>比如, i=5 的时候, w[i]=4 已经更新了 dp[9]=9, dp[5]=5, 此时 j 从 m 遍历递减, 又从 9 开始, 有<code>dp[9] = dp[5] + w[i]</code>, 就把 i=5, 即 w[i]=4 添加进<code>choice[9][5] = true</code>, 作为路径之一</p>
<pre><code class="lang-c++">sort(w + 1, w + n + 1, cmp);  //从大的面额找起
for (int i = 1; i &lt;= n; ++i) {
    for (int j = m; j &gt;= w[i]; --j) {    //容量从 m 递减,直到比 w[j] 小则装不下,忽略
        if(dp[j] &lt;= dp[j-w[i]] + w[i]){
            choice[i][j] = true;
            dp[j] = dp[j-w[i]] + w[i];
        }
    }
}
if(dp[m] != m) cout &lt;&lt; &quot;No Solution&quot;;
else{
    int v = m, index = n;  //v 表示目标容量, n 表示初始序号在末尾(从最小的选起)

    while (v &gt; 0){
        if(choice[index][v]){  //目标为 v 的时候, w[index] 可以作为选项
            arr.push_back(w[index]);
            v -= w[index];
        }
        index--;
    }
    //输出 arr
}
</code></pre>
<h3 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h3><p>一道基础的背包问题, 居然思考了我一整个下午, 算法基础真的薄弱. 鉴于网上的题解要么不够大佬, 代码不够最优; 要么太过于大佬, 解释得很简略. 于是我吧最大佬的代码, 用最清楚的语言解释, 是对自己思路的一个锻炼, 也希望帮助后来的萌新们.</p>
<hr>
<p><span id="1044"></span></p>
<h2 id="1044-Shopping-in-Mars-特定值子序列和-二分查找"><a href="#1044-Shopping-in-Mars-特定值子序列和-二分查找" class="headerlink" title="1044 Shopping in Mars (特定值子序列和, 二分查找)"></a>1044 Shopping in Mars (特定值子序列和, 二分查找)</h2><h3 id="1-题目大意-13"><a href="#1-题目大意-13" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>求一串的数字中连续的一段，使得这个连续的段内数字的和恰好等于所期望的值m. 如果不能找到恰好等于，就找让自己付出最少的价格（总和必须大于等于所给值）的那段区间, 求所有可能的结果.<br>简而言之, 就是找一个连续子序列, 恰好等于 target</p>
<h3 id="2-个人代码-1"><a href="#2-个人代码-1" class="headerlink" title="2. 个人代码"></a>2. 个人代码</h3><p>因为给定的金币序列是乱序的, 这题一开始没想到可以二分法. 其实题目要求的是连续的子段, 那么就可以逐级叠加求<code>sum</code>, <code>a[j] - a[i-1]</code>即是 i~j 这一段的子段和. 而这个逐级叠加的<code>sum</code>数组, 就是一个完美的递增序列.</p>
<p>注意解题技巧, 需要多个参数时, 可以采用<code>int &amp;j, int &amp;temp_sum</code>引用传参.</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
using namespace std;

vector&lt;int&gt; sum, ans;
int n, m;

// 从 i 开始, 以 n 结尾的序列, 二分查找
// 目标: 找到右端点, 刚好比左端点大 m
void search(int i, int &amp;j, int &amp;temp_sum){
    int left = i, right = n;
    int target = sum[left-1] + m;
    while (left &lt; right){
        // 保留右侧的二分查找, 不求找到而退出
        // 最后让 left==right 时退出, 此时是比 target 大的最小数
        // 因为 mid 小了的时候, 总是舍弃左端点, mid 大了的时候, 右端点被保留
        int mid = (left+right)/2;
        if(sum[mid] &lt; target)
            left = mid + 1;
        else
            right = mid;
    }
    j = right;
    temp_sum = sum[right] - sum[i-1];
}

int main(){
    cin &gt;&gt; n &gt;&gt; m;
    sum.resize(n+1);
    sum[0] = 0;
    for (int i = 1; i &lt;= n; ++i) {  //转化为递增序列, 得以应用二分, 提高效率
        cin &gt;&gt; sum[i];
        sum[i] += sum[i-1];
    }
    int min_ans = sum[n];  //求比 m 大的最小和
    for (int i = 1; i &lt;= n; ++i) {
        int j=0, temp_sum=0;  //仅仅作为参数传回来而已
        search(i, j, temp_sum);
        if(temp_sum &lt; m) continue;
        else{
            if(temp_sum &lt; min_ans){
                min_ans = temp_sum;
                ans.clear();
                ans.push_back(i);
                ans.push_back(j);
            }
            else if (temp_sum == min_ans){
                ans.push_back(i);
                ans.push_back(j);
            }
        }
    }
    for (int i = 0; i &lt; ans.size(); i += 2) {
        cout &lt;&lt; ans[i] &lt;&lt; &quot;-&quot; &lt;&lt; ans[i+1] &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<hr>
<p><span id="1085"></span></p>
<h2 id="1085-Perfect-Sequence-二分查找-upper-bound-双指针"><a href="#1085-Perfect-Sequence-二分查找-upper-bound-双指针" class="headerlink" title="1085 Perfect Sequence (二分查找, upper_bound, 双指针)"></a>1085 Perfect Sequence (二分查找, upper_bound, 双指针)</h2><h3 id="1-题目大意-14"><a href="#1-题目大意-14" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>设这个数列中的最大值是M，最小值是m，如果M &lt;= m * p，则称这个数列是完美数列. 现在给定一个序列, 求满足完美序列的最长子序列长度</p>
<h3 id="2-二分法"><a href="#2-二分法" class="headerlink" title="2.二分法"></a>2.二分法</h3><p>本题可以应用 upper_bound 来查找, 既然要求满足最大的<code>max &lt;= p*min</code>, 那么找到第一个<code>max &gt; p*min</code>即可, 即找到第一个大于target 的元素.</p>
<p><strong>upper_bound 代码</strong></p>
<pre><code class="lang-c++">int bin_sear_upper(int left, int right, int target){
    int mid;
    while (left &lt; right){
        mid = (left+right)/2;
        if(a[mid] &gt; target)
            right = mid;
        else
            left = mid + 1;
    }
    return right;
}
</code></pre>
<p>关键点 1: <code>left &lt; right</code>到最后必然会夹出 left==right 返回即可.<br>而普通的查找定值<code>if(a[mid]==target)</code>, 需要<code>left &lt;= right</code>作为条件, 找不到就返回-1</p>
<p>关键点 2: 先判断<code>&gt;</code>, 让<code>right = mid</code>目的是尽可能保留大数,<code>left = mid + 1</code>小数不保留无所谓.</p>
<p><strong>lower_bound 代码</strong></p>
<pre><code class="lang-c++">if(a[mid] &gt;= target)
    right = mid;
else
    left = mid + 1;
</code></pre>
<p>只需换为<code>&gt;=</code>即可, 其他完全一样, 也是保大.</p>
<p>比如 3 4 5 5 7 8 8 8 9, target 为 8.<br>upper_bound 找到的为 3 4 5 5 7 [8] 8 8 9, lower_bound 找到的为 3 4 5 5 7 8 8 8 [9].</p>
<p>这三种二分法基本可以涵盖所有二分查找的应用.</p>
<h3 id="3-个人代码-9"><a href="#3-个人代码-9" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><pre><code class="lang-c++">int search(int left, long long target){  // 寻找比 target 小的最大数 upper_bound
    int right = n-1, mid;
    if(a[right] &lt;= target){  //最大的比 target 小
        return right;
    }
    while (left &lt; right){
        mid = (left + right)/2;
        if(a[mid] &gt; target)
            right = mid;
        else
            left = mid + 1;
    }
    return right-1;  // 最后 left==right 找到的是第一个比 tar 大的数, -1 即可
}
</code></pre>
<p>应用的是 upper_bound, <code>right-1</code>即可得到满足<code>max &lt;= p*min</code>的最大数字.</p>
<h3 id="4-坑点"><a href="#4-坑点" class="headerlink" title="4. 坑点"></a>4. 坑点</h3><ol>
<li><code>段错误</code> 数组开的不够大, 递归调用过多</li>
<li><code>答案错误</code> 发现存在溢出, int 最大管到 $10^9$, 此题乘起来之后会超过, 要用 long long !</li>
</ol>
<h3 id="5-Two-points-双指针法"><a href="#5-Two-points-双指针法" class="headerlink" title="5. Two points 双指针法"></a>5. Two points 双指针法</h3><p>瞬间非常简单</p>
<pre><code class="lang-c++">    sort(v.begin(), v.end());
    int result = 0, temp = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + result; j &lt; n; j++) {  
        //result 已经是最长了, 之后的直接从 result 以上的找起
            if (v[j] &lt;= v[i] * p) {
                temp = j - i + 1;
                if (temp &gt; result)
                    result = temp;
            } else {
                break;
            }
        }
    }
    cout &lt;&lt; result;
</code></pre>
<p>效率对比差距明显</p>
<p><img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://i.loli.net/2020/02/12/Buth7AGTcCpPonS.png" alt="图片替换文本" width="140" height="180"/></p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hopenx.github.io" rel="external nofollow noreferrer">HopenX</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hopenx.github.io/2020/02/06/pat-advance/">https://hopenx.github.io/2020/02/06/pat-advance/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://hopenx.github.io" target="_blank">HopenX</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/PAT/">
                                    <span class="chip bg-color">PAT</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/02/06/ml-study-notes/">
                    <div class="card-image">
                        
                        
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/featureimages/6.jpg" class="responsive-img" alt="机器学习概述">
                        
                        <span class="card-title">机器学习概述</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            机器学习概述，常见的机器学习算法概览，包括监督学习和非监督学习，损失函数，优化方法，评价指标，参数调优的基本概念
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-02-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    机器学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">机器学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/02/02/hello-world/">
                    <div class="card-image">
                        
                        
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/featureimages/21.jpg" class="responsive-img" alt="欢迎来到 Hexo">
                        
                        <span class="card-title">欢迎来到 Hexo</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本博客采用 Hexo 快速搭建，也欢迎大家上手使用 Hexo，选择自己喜欢的主题，省时省力，工具齐全，生态优越，可扩展性好
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-02-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            HopenX
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://hopenx.github.io" target="_blank">HopenX</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">34.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "2";
                    var startHour = "0";
                    var startMinute = "";
                    var startSecond = "";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 ";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/hopenx" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1152214965" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1152214965" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/bo-xue-du-zhi-5" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/bo-xue-du-zhi-5" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>

<script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/instantpage/instantpage.js" type="module"></script>
    

<script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>
