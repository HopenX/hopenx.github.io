<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="OJ 做题笔记, HopenX">
    <meta name="description" content="PAT-Advanced Level 重点题目分类记录，对于夯实数据结构和算法基础有很重要的帮助. 后期加入了 TK 题库, 牛客网等等.">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>OJ 做题笔记 | HopenX</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/css/highlight/styles/github.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"></head>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    <div>
                        
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/logo.png" class="logo-img" alt="LOGO">
                        
                        <span class="logo-span">HopenX</span>
                    </div>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HopenX</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/HopenX/hopenx.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #267871;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/HopenX/hopenx.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>



    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/featureimages/1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">OJ 做题笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #267871;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #267871;
    }

    #toc-content .is-active-link::before {
        background-color: #267871;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        
<style type="text/css">

    #articleContent a {
        color: #267871; !important;
    }

    #artDetail .post-cate a {
        color: #267871; !important;
    }

    blockquote {
        border-left: 5px solid #267871; !important;
    }

    #artDetail .reprint a {
        color: #267871; !important;
    }

    pre {
        background: #f8f8f8;
    }

    .code-area::after {
        content: " ";
        position: absolute;
        border-radius: 50%;
        /*background: #ff5f56;*/
        width: 12px;
        height: 12px;
        top: 0;
        left: 12px;
        margin-top: 12px;
        /*-webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;*/
        /*box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;*/
    }

    @font-face {
        font-family: 'Menlo';
        font-style: normal;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/css/Menlo-Regular.ttf') format('ttf');
    }

    code{
        font-family: 'Menlo';
    }


</style>


<script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/PAT/">
                                <span class="chip bg-color">PAT</span>
                            </a>
                        
                            <a href="/tags/OJ/">
                                <span class="chip bg-color">OJ</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                算法
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-02-06
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.7k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="PAT-甲级-做题笔记"><a href="#PAT-甲级-做题笔记" class="headerlink" title="PAT-甲级 做题笔记"></a>PAT-甲级 做题笔记</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h3><p>0000 <a href="#0000">做题 Tips 基本经验</a><br>1010 <a href="#1010">Radix (进制转换/二分法)</a><br>1015 <a href="#1015">Reversible Primes (进制转换+判断素数: 可取用函数)</a><br>NK <a href="#NK-jzzh">10进制 VS 2进制 (任意长度字符串进制转换: 可取用函数)</a><br>1016 <a href="#1016">Phone Bills (日期类计算)</a><br>NK <a href="#NK-dzs">大整数乘除法 手写模拟</a></p>
<h3 id="查找-排序-模拟"><a href="#查找-排序-模拟" class="headerlink" title="查找/排序/模拟"></a>查找/排序/模拟</h3><p>1012 <a href="#1012">The Best Rank (应用问题，数据结构设计，多维度排序)</a><br>1014 <a href="#1014">Waiting in Line (队列应用，排队问题)</a><br>1044 <a href="#1044">Shopping in Mars (特定值子序列和, 二分查找)</a><br>1085 <a href="#1085">Perfect Sequence (二分查找, upper-bound, 双指针)</a><br>1071 <a href="#1071">Speech Patterns (词频统计)</a><br>1067 <a href="#1067">Sort with Swap(0, i) (贪心, 元素归位)</a><br>NK <a href="#NK-dcth">单词替换 (手写 split 函数)</a><br>NK <a href="#NK-sxzs">扇形着色问题</a></p>
<h3 id="动态规划算法-DP"><a href="#动态规划算法-DP" class="headerlink" title="动态规划算法 DP"></a>动态规划算法 DP</h3><p>NK <a href="#dp-set">常见动态规划算法合集</a><br>1007 <a href="#1007">Maximum Subsequence Sum(最大子序列和)</a><br>1040 <a href="#1040">Longest Symmetric String (求最长对称子串, DP)</a><br>1045 <a href="#1045">Favorite Color Stripe (最长不下降子序列, DP)</a><br>1068 <a href="#1068">Find More Coins (0-1 背包问题, DP)</a><br>HustOJ 1130 <a href="#H1130">分成两个尽可能接近的子数组 (背包问题, DP)</a><br>TK 21802 <a href="#T21802">采药 (最基础的容量-价值最大化, 背包问题, DP)</a><br>TK 1131 <a href="#T1131">分梨 (m 个梨子装进 n 个盘子, DP)</a><br>TK 1132 <a href="#T1132">最长公共子序列 LCS (入门经典 DP)</a><br>TK 4861 <a href="#T4861">最长不下降子序列 (入门经典 DP)</a><br>TK 5578 <a href="#T5578">最大约数和 (DP)</a><br>TK 5579 <a href="#T5579">环形石子合并问题 (区间DP)</a></p>
<h3 id="树算法"><a href="#树算法" class="headerlink" title="树算法"></a>树算法</h3><p>1004 <a href="#1004">Counting Leaves (计算叶节点数，DFS/BFS 树算法)</a><br>1020 <a href="#1020">Tree Traversals (已知后序和中序，转前序/层序)</a><br>1021 <a href="#1021">Deepest Root (求树中最长的路径，DFS，连通分量)</a><br>1100 <a href="#1100">Complete Binary Tree (判断完全二叉树 层序遍历)</a></p>
<h3 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h3><p>1003 <a href="#1003">Emergency (Dijkstra 算法)</a><br>1013 <a href="#1013">Battle Over Cities (图的遍历，统计强连通分量的个数，DFS)</a><br>1018 <a href="#1018">Public Bike Management (图最短路径 Dijkstra + DFS)</a><br>NK <a href="#NK-ctgc">畅通工程 (并查集, 最小生成树 Kruscal)</a><br>NK <a href="#NK-graph">常见图算法合集</a></p>
<hr>
<h2 id="0000-做题-Tips-基本经验"><a href="#0000-做题-Tips-基本经验" class="headerlink" title="0000 做题 Tips 基本经验"></a>0000 做题 Tips 基本经验<span id="0000"></span></h2><ol>
<li>最后千万别栽在头文件上，比如 reverse() 属于 &lt; algorithm&gt;，比如 memset 属于 string.h<br>一定要多检查 corner case, 比如 n=1, n=0</li>
<li>设置输出形式<pre><code class="lang-c++">cout &lt;&lt; setw(4) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; v[i];
</code></pre>
</li>
<li><p>int 最大范围 $-2^{31}$=-2147483648 到 $2^{31}$-1=2147483647  (10 位数)</p>
</li>
<li><p>INT_MAX 和 INT_MIN 都在<code>#include &lt;limits.h&gt;</code>中定义的<br>其中 INT_MAX 就等于<code>0x7fffffff</code>, 也即<code>2147483647</code></p>
</li>
<li><p>输入一两个数, 用 cin 无伤大雅, 遇到下面这种</p>
<pre><code class="lang-c++">for (int j = 0; j &lt; m; ++j) {
     cin &gt;&gt; temp; }
</code></pre>
<p>由于 m 可以达到 $10^5$, cin 就会显得很耗时, 要用 scanf</p>
</li>
<li><p>结构体不能直接整个赋值</p>
</li>
</ol>
<pre><code class="lang-cpp">station st = {0, 0};
scanf(&quot;%lf %lf&quot;, &amp;st.price, &amp;st.dis);
v.push_back(st);
</code></pre>
<ol>
<li>scanf 读取字符串注意</li>
</ol>
<p>一定要预先分配好空间，即使是数组也要. 而且 string a 一定要 <code>&amp;a[0]</code></p>
<pre><code class="lang-cpp">int main()
{
    string a;
    a.resize(100); //需要预先分配空间
    scanf(&quot;%s&quot;, &amp;a[0]);
    puts(a.c_str());
    return 0;
}

char str[20];
scanf(&quot;%s&quot;,str);
char* str=(char*)malloc(15*sizeof(char));
scanf(&quot;%s&quot;,str);
</code></pre>
<ol>
<li><p>map 初始化方法</p>
<pre><code class="lang-cpp">map&lt;string, int&gt; getMonth{
 {&quot;January&quot;,1 },
 {&quot;February&quot;,2},
 {&quot;March&quot;,3}
}
</code></pre>
</li>
<li><p>字符串格式抓换</p>
<pre><code class="lang-cpp">scanf(&quot;%s&quot;, a); 
sscanf(a, &quot;%lf&quot;, &amp;temp); 
sprintf(b, &quot;%.2f&quot;,temp);
</code></pre>
</li>
</ol>
<h3 id="附-甲级题目分类"><a href="#附-甲级题目分类" class="headerlink" title="附:甲级题目分类"></a>附:甲级题目分类</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://i.loli.net/2020/02/06/Y49WNI6DpA3hSKX.png" alt="甲级题目分类"></h2><p><span id="1003"></span></p>
<h2 id="1003-Emergency-Dijkstra-算法"><a href="#1003-Emergency-Dijkstra-算法" class="headerlink" title="1003 Emergency (Dijkstra 算法)"></a>1003 Emergency (Dijkstra 算法)</h2><h3 id="1-题目大意"><a href="#1-题目大意" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>n个城市m条路，每个城市有救援小组，所有的边的边权已知. 给定起点和终点，求从起点到终点的最短路径条数以及最短路径上的救援小组数目之和. 如果有多条就输出点权（城市救援小组数目）最大的那个</p>
<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>用一遍Dijkstra算法～救援小组个数相当于点权，用Dijkstra求边权最小的最短路径的条数，以及这些最短路径中点权最大的值～dis[i]表示从出发点到i结点最短路径的路径长度，num[i]表示从出发点到i结点最短路径的条数，w[i]表示从出发点到i点救援队的数目之和～当判定dis[u] + e[u][v] &lt; dis[v]的时候，不仅仅要更新dis[v]，还要更新num[v] = num[u], w[v] = weight[v] + w[u]; 如果dis[u] + e[u][v] == dis[v]，还要更新num[v] += num[u]，而且判断一下是否权重w[v]更小，如果更小了就更新w[v] = weight[v] + w[u]</p>
<h3 id="3-个人代码"><a href="#3-个人代码" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">PTA-1003</a></p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

//Dijkstra 算法：单源最短路径
int n, m, c1, c2;
int e[510][510], weight[510], dis[510], num[510], w[510];
//边的邻接矩阵，每个点的权值，从出发点到i的距离，最短距离边数，最大权重和
const int Inf = 99999999;
bool visit[510];

int main(){
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; weight[i];
    }
    fill(e[0], e[0]+510*510, Inf);  //整个邻接矩阵填正无穷，默认不可达
    fill(dis, dis+510, Inf);
    int a,b,c;
    for (int j = 0; j &lt; m; ++j) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        e[a][b] = e[b][a] = c;  //一定要对称
    }

    dis[c1] = 0;
    num[c1] = 1;
    w[c1] = weight[c1];  //初始化

    for (int i = 0; i &lt; n; ++i) {    //每个点都要作为起始点 开始一遍
        int u = -1, min_d = Inf;        //每次循环重置

        //本次循环表示从 i 出发, i -&gt; j
        for (int j = 0; j &lt; n; ++j) {
            if(!visit[j] &amp;&amp; dis[j] &lt; min_d){   //找从本点出发的最小边
                u = j;
                min_d = dis[j];
            }
        }
        if(u == -1) break;
        visit[u] = true;

        //得到一条 i-&gt;u, 即 dis[], 用来更新最短路径
        //之前没更新的、在后续得到更新，达到最优
        for (int v = 0; v &lt; n; ++v) {
            if(!visit[v] &amp;&amp; e[u][v] != Inf){
                if(dis[u] + e[u][v] &lt; dis[v]){
                    dis[v] = dis[u] + e[u][v];
                    w[v] = w[u] + weight[v];
                    num[v] = num[u];
                } else if(dis[u] + e[u][v] == dis[v]){
                    num[v] += num[u];
                    if(w[v] &lt; w[u]+weight[v])
                        w[v] = w[u]+weight[v];   //携带尽可能多的人
                }
            }
        }
    }

    cout &lt;&lt; num[c2] &lt;&lt; &quot; &quot; &lt;&lt; w[c2];   //从出发点到c2
    return 0;
}
</code></pre>
<h3 id="4-学习要点"><a href="#4-学习要点" class="headerlink" title="4. 学习要点"></a>4. 学习要点</h3><blockquote>
<p>1.真正理解单源最短路径，每一次选择的 dis 都是相对于源点的最短路径<br>2.大数组要设为全局变量<br>3.外层循环 i：n 次循环，每次访问一个新点，保证 n 个点全访问到；内层循环 j：继续寻找还未访问的点，找 dis 最小的访问；内层循环 k：更新所有能够更新的 dis</p>
</blockquote>
<hr>
<p><span id="1004"></span></p>
<h2 id="1004-Counting-Leaves-dfs-bfs-树算法"><a href="#1004-Counting-Leaves-dfs-bfs-树算法" class="headerlink" title="1004 Counting Leaves (dfs/bfs 树算法)"></a>1004 Counting Leaves (dfs/bfs 树算法)</h2><h3 id="1-题目大意-1"><a href="#1-题目大意-1" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出一棵树，问每一层各有多少个叶子结点</p>
<h3 id="2-坑"><a href="#2-坑" class="headerlink" title="2. 坑"></a>2. 坑</h3><pre><code>list[tmp].lev = list[fa].lev + 1;  //出问题,不一定按照顺序输入
</code></pre><p>有可能先 03 后 01，fa 的 lev 还没确定，不能给孩子节点 +1</p>
<pre><code>3 2
03 1 02
01 1 03
</code></pre><h3 id="3-个人代码-1"><a href="#3-个人代码-1" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184" target="_blank" rel="noopener">PTA-1004</a></p>
<h3 id="4-正确方法"><a href="#4-正确方法" class="headerlink" title="4. 正确方法"></a>4. 正确方法</h3><pre><code class="lang-cpp">void dfs(int fa){
    for (auto &amp;ch : list[fa].v) {
        list[ch].lev = list[fa].lev + 1;
        dfs(ch);
    }
}
dfs(1);   //通过 DFS 一层层给叶子节点 lev+1
</code></pre>
<hr>
<p><span id="1007"></span></p>
<h2 id="1007-Maximum-Subsequence-Sum-最大子序列和"><a href="#1007-Maximum-Subsequence-Sum-最大子序列和" class="headerlink" title="1007 Maximum Subsequence Sum (最大子序列和)"></a>1007 Maximum Subsequence Sum (最大子序列和)</h2><h3 id="1-题目大意-2"><a href="#1-题目大意-2" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>求最大连续子序列和，输出最大的和以及这个子序列的开始值和结束值. 如果所有数都小于0，那么认为最大的和为0，并且输出首尾元素</p>
<h3 id="2-分析-1"><a href="#2-分析-1" class="headerlink" title="2.分析"></a>2.分析</h3><p>本质上是<strong>动态规划</strong>的思想，数组为<code>vec[]</code>，设<code>dp[i]</code> 是以<code>vec[i]</code>结尾的子数组的最大和，对于元素<code>vec[i+1]</code>, 它有两种选择：<code>vec[i+1]</code>接着前面的子数组构成最大和; <code>vec[i+1]</code>自己单独构成子数组. 则<code>dp[i+1] = max{dp[i]+vec[i+1],  vec[i+1]}</code></p>
<p>简化则用一个 temp_sum 和一个 temp_first 解决，真正最大和为 sum，起始点为 first 和 last，建立局部和全局的关系. 如果 <code>temp_sum &lt; 0</code>, 说明目前这一段对后续的序列和已经没有加成作用，可以舍弃另立门户，令<code>temp_sum = 0</code></p>
<h3 id="3-个人代码-2"><a href="#3-个人代码-2" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><pre><code class="lang-cpp">//初始值设置容易坑：sum要为-1 才能开始
int sum=-1, temp_sum=0, first=0, last=k-1, temp_first=0;
for (int j = 0; j &lt; k; ++j) {
    temp_sum += a[j];
    if(temp_sum &lt; 0){
        temp_sum = 0;
        temp_first = j+1;   //本段已经可以舍弃，开始新一段
    } else if(temp_sum &gt; sum){
        sum = temp_sum;
        first = temp_first;
        last = j;
    }
}
if(sum &lt; 0) sum = 0;  //如果全负则为 0，根据题目要求不要漏情况
</code></pre>
<h3 id="4-类似题"><a href="#4-类似题" class="headerlink" title="4. 类似题"></a>4. 类似题</h3><h5 id="1-最长无重复子串"><a href="#1-最长无重复子串" class="headerlink" title="1) 最长无重复子串"></a>1) <a href="https://www.cnblogs.com/grandyang/p/4480780.html" target="_blank" rel="noopener">最长无重复子串</a></h5><h5 id="2-满足-gt-k-的最短连续子序列"><a href="#2-满足-gt-k-的最短连续子序列" class="headerlink" title="2) 满足 &gt;=k 的最短连续子序列"></a>2) 满足 &gt;=k 的最短连续子序列</h5><p>核心思想: 要求连续, 可以用<code>双指针法</code>, 记录 start 和 end, end 作为探路, start 作为后备, 满足之后 start 就可以前移. 整个过程中通过 min 沉淀出最短长度.</p>
<pre><code class="lang-cpp">int start = 0, end = 0, ans = n, sum = 0;
while (end &lt; n){
    if(sum &lt; k)
        sum += a[end];
    while (sum &gt;= k){   //一直移到小于 k 为止, 满足 sum &gt;= k 的就有计数资格
        ans = min(ans, end-start+1);
        sum -= a[start++];   //start 后移
    }
    end++;

}
cout &lt;&lt; ans;
</code></pre>
<hr>
<p><span id="1010"></span></p>
<h2 id="1010-Radix-进制转换-二分法）"><a href="#1010-Radix-进制转换-二分法）" class="headerlink" title="1010 Radix (进制转换/二分法）"></a>1010 Radix (进制转换/二分法）</h2><h3 id="1-题目大意-3"><a href="#1-题目大意-3" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定两个相等数，已知一个数的进制，求另外一个数的进制（radix-&gt;基数）</p>
<h3 id="2-分析-2"><a href="#2-分析-2" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>通用函数<code>cal(string str, int radix)</code>把任意进制的数转换为 10 进制数<br>在使用搜索遍历，找到另一个数对应的进制</p>
<h3 id="3-个人代码-3"><a href="#3-个人代码-3" class="headerlink" title="3.个人代码"></a>3.个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536" target="_blank" rel="noopener">PTA-1010</a></p>
<p>转换函数</p>
<pre><code class="lang-cpp">//任意进制转换为 10 进制
long long cal(string str, long long radix){
    long long target=0, bak = 1;
    reverse(str.begin(), str.end());
    for (char c : str) {
        if(isdigit(c))
            target += (c - &#39;0&#39;) * bak;
        else
            target += (c - &#39;a&#39; + 10) * bak;
        bak *= radix;  //也可以使用&lt;cmath&gt;的 pow()函数
    }
    return target;
}
</code></pre>
<p>搜索函数</p>
<pre><code class="lang-cpp">long long find_radix(string str, long long tar){
    char c = *max_element(str.begin(), str.end());  //最大字母
    //进制至少比最大字母要大
    long long low = isdigit(c) ? c-&#39;0&#39; : c-&#39;a&#39;+10;
    low += 1;  //必须要加一,至少多1
    long long high = max(low, tar);  //进制最大不会大于目标 tar
    while (low &lt;= high){
        long long mid = (low+high)/2;
        long long tmp = cal(str, mid);
        if(tmp &lt; 0 || tmp &gt; tar) high = mid - 1;  //小于 0 也是进制太大
        else if(tmp == tar) return mid;
        else low = mid + 1;
    }
    return -1;
}
</code></pre>
<h3 id="4-学习要点-1"><a href="#4-学习要点-1" class="headerlink" title="4. 学习要点"></a>4. 学习要点</h3><blockquote>
<ol>
<li>进制转换这种大数字的乘法很容易溢出，必须要用 <code>long long</code></li>
<li>暴力搜索（从 2 到 ∞ 容易超时）最好用二分法，并且限定范围：最小是 <code>low</code> 至少是最大的那个字母+1，比如 fff 最少是 15+1=16 进制，最大是<code>high</code>不超过目标 <code>tar</code></li>
<li>可以使用反向迭代器 <code>it = n.rbegin(); it != n.rend()</code>代替<code>reverse()</code></li>
</ol>
</blockquote>
<hr>
<h2 id="1012-The-Best-Rank-数据结构设计-多维度排序"><a href="#1012-The-Best-Rank-数据结构设计-多维度排序" class="headerlink" title="1012 The Best Rank (数据结构设计/多维度排序)"></a>1012 The Best Rank (数据结构设计/多维度排序)<span id="1012"></span></h2><h3 id="1-题目大意-4"><a href="#1-题目大意-4" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>找出每个人自己最优势的科目，也就是单独排名最好的科目，优先级 A &gt; C &gt; M &gt; E</p>
<ul>
<li>Sample Input:<pre><code>5 6
310101 98 85 88
310102 70 95 88
310103 82 87 94
310104 91 91 91
310105 85 90 90
310101
310102
310103
310104
310105
999999
</code></pre></li>
<li>Sample Output:<pre><code>1 C
1 M
1 E
1 A
3 A
N/A
</code></pre></li>
</ul>
<h3 id="2-个人代码"><a href="#2-个人代码" class="headerlink" title="2. 个人代码"></a>2. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480" target="_blank" rel="noopener">PTA-1012</a></p>
<h3 id="3-学习要点"><a href="#3-学习要点" class="headerlink" title="3. 学习要点"></a>3. 学习要点</h3><p>数据结构设计</p>
<pre><code class="lang-cpp">struct node{
    //一定要用数组形式，避免过多变量 int c, m, e, c_r, m_r, e_r, a_r;
    int id, best;
    int score[4], rank[4];
}stu[2001];  //输入学生序列，非学号排序

int exist[1000000], flag=-1; //exist 至少 &gt;0, 顺便建立 id-输入序号 映射

//使用 flag 配置作用，避免写过多重复的 cmp 函数
bool cmp(node &amp;a, node &amp;b){ return a.score[flag] &gt; b.score[flag];}
</code></pre>
<p>输入后，利用<code>exist[stu[k].id] = k + 1; k++</code> 依次建立映射<br>输出时，利用<code>cin &gt;&gt; tmp; ex = exist[tmp]</code>和<code>stu[ex-1]</code>实现映射，无需 find<br>处理时，使用<code>sort(stu, stu+n, cmp)</code> 循环 <code>flag++</code>，实现分学科多次排序，确定 <code>rank[]</code></p>
<hr>
<p><span id="1013"></span></p>
<h2 id="1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）"><a href="#1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）" class="headerlink" title="1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）"></a>1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）</h2><h3 id="1-题目大意-5"><a href="#1-题目大意-5" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出n个城市之间有相互连接的m条道路，当删除一个城市和其连接的道路的时候，问其他几个剩余的城市至少要添加多少个路线，才能让它们重新变为连通图</p>
<h3 id="2-分析-3"><a href="#2-分析-3" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>n 连通分量，最少需要 n-1 条边相连，所以本题实质就是求「去除某点及其相连的边」后，剩余的「连通分量个数」是一个图算法，需要用图的遍历来解决 (DFS)</p>
<blockquote>
<p>求连通分量依据：一次 <code>dfs()</code>走到底，可以访问完一个连通分量</p>
</blockquote>
<p>数据结构：</p>
<blockquote>
<p>涉及图的遍历，要考虑 <code>visit[]</code>数组<br>图的路径存储，使用二维矩阵</p>
</blockquote>
<h3 id="3-个人代码-4"><a href="#3-个人代码-4" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">PTA-1013</a></p>
<pre><code class="lang-cpp">for (int i = 0; i &lt; k; ++i) {
        int cur, cnt=0;
        cin &gt;&gt; cur;
        fill(visited, visited+n, false);
        visited[cur] = true;  //相当于把本点去除
        for (int j = 1; j &lt;= n; ++j) {  //依次计算所有连通分量，而非从本点出发
            if(!visited[j]){
                dfs(j);
                cnt++;
            }
        }
        cout &lt;&lt; cnt-1 &lt;&lt; endl;
    }
</code></pre>
<pre><code class="lang-cpp">void dfs(int st){   //只用来 visit，不负责计数
    visited[st] = true;
    for (int i = 0; i &lt;= n; ++i)
        if(!visited[i] &amp;&amp; e[st][i]){   //未访问且有路
            dfs(i);
        }
}
</code></pre>
<h3 id="4-坑点"><a href="#4-坑点" class="headerlink" title="4.坑点"></a>4.坑点</h3><p>有些题目, 没有给定 n 的范围, 开二维数组可能会内存超限. 所以可以使用<code>邻接表</code>, vector 的数组.</p>
<pre><code class="lang-cpp">
vector&lt;int&gt; Adj[maxn];

//输入时
if(m!=n){
    Adj[n].push_back(m);
    Adj[m].push_back(n);
}
else{
    Adj[n].push_back(m);
}

//遍历时
void DFS(int n)
{
    flag[n]=true;
    for(int i=0; i&lt;Adj[n].size(); ++i) //只遍历自己的邻接点
    {
        int v=Adj[n][i];
        if(flag[v]==false)
        {
            DFS(v);
        }
    }
}
</code></pre>
<hr>
<p><span id="1014"></span></p>
<h2 id="1014-Reversible-Primes（队列应用-排队问题"><a href="#1014-Reversible-Primes（队列应用-排队问题" class="headerlink" title="1014 Reversible Primes（队列应用 排队问题"></a>1014 Reversible Primes（队列应用 排队问题</h2><h3 id="1-题目大意-6"><a href="#1-题目大意-6" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>n个窗口，每个窗口可以排队m人. 有k位用户需要服务，给出了每位用户需要的minute数，所有客户在8点开始服务，如果有窗口还没排满就入队，否则就在黄线外等候. 如果有某一列有一个用户走了服务完毕了，黄线外的人就进来一个. 如果同时就选窗口数小的. 求q个人的服务结束时间.<br>如果一个客户在17:00以及以后还没有开始服务（此处不是结束服务是开始17:00）就不再服务输出sorry；如果这个服务已经开始了，无论时间多长都要等他服务完毕. </p>
<h3 id="2-学习要点"><a href="#2-学习要点" class="headerlink" title="2. 学习要点"></a>2. 学习要点</h3><p>面对此类题目，总想按照 timeline 每分每秒去决策，其实队列的问题用队列解决. </p>
<p>以每个窗口为单位设计结构体，<code>poptime</code> 用于刚入黄线的人决策，<code>endtime</code> 用于已经在队内的人是否会 sorry 决策，<code>q</code> 表示本队列内排队情况. </p>
<p>给定客户序列，则以每一个客户为循环单位<code>(index++)</code>，队列有一个进就会有一个出，每次变动一个单位，更新各个队列的<code>poptime endtime q</code>等变量. </p>
<pre><code class="lang-cpp">struct node {
    int poptime, endtime;  //队首的人出队（结束）的时间, 队尾的人结束的时间
    queue&lt;int&gt; q;
};

int index = 1;
    //第 1 步：n*m 个客户先抢占黄线内, 直接瞬间涌入，不存在选择
    for (int i = 1; i &lt;= cap; ++i) {    //看做行和列，先抢第一行
        for (int j = 1; j &lt;= n; ++j) {
            if(index &lt;= k){
                win[j].q.push(time[index]);
                if(win[j].endtime &gt;= 540)
                    sorry[index] = true;
                win[j].endtime += time[index];
                if(i == 1)  //对于第一行，出队时间即本队结束时间，做一个初始化
                    win[j].poptime = win[j].endtime;
                res[index] = win[j].endtime;  //刚进来的，自己是队尾，队伍结束就是自己结束
                index++;
            }
        }
    }

    //第 2 步：后续的客户
    while (index &lt;= k){   //while一次循环表示一个客户的选择
        int temp_min = win[1].poptime, temp_win = 1;  //初始化
        for (int i = 2; i &lt;= n; ++i) {   //找最早出队的
            if(win[i].poptime &lt; temp_min){
                temp_win = i;
                temp_min = win[i].poptime;
            }
        }
        win[temp_win].q.pop();
        win[temp_win].q.push(time[index]);
        win[temp_win].poptime += win[temp_win].q.front(); //更新：最前面那个人完成的时间就是出队时间
        if(win[temp_win].endtime &gt;= 540)  //endtime 还未更新，是看的前一个人的完成时间，是否超时
            sorry[index] = true;
        win[temp_win].endtime += time[index];  //更新：刚进来的这个人的完成时间就是本队的完成时间
        res[index] = win[temp_win].endtime;
        index++;
    }
</code></pre>
<hr>
<p><span id="1015"></span></p>
<h2 id="1015-判断素数-进制转换"><a href="#1015-判断素数-进制转换" class="headerlink" title="1015 判断素数 进制转换"></a>1015 判断素数 进制转换</h2><h3 id="1-可以直接取用的函数"><a href="#1-可以直接取用的函数" class="headerlink" title="1. 可以直接取用的函数"></a>1. 可以直接取用的函数</h3><pre><code class="lang-cpp">//计算任意进制的方法, 10进制-&gt;任意进制
void cal(){
    int a, b;
    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
    int arr[40], index = 0;
    while(a != 0) {
        arr[index++] = a % b;
        a = a / b;
    }
}

//判断素数
bool isPrime(int x){
    if(x == 2) return true;
    if(x &lt;= 1 ) return false;
    int loop = (int)sqrt(x * 1.0);
    for (int i = 2; i &lt;= loop; ++i) {
        if(x % i == 0) return false;
    }
    return true;
}
</code></pre>
<ol>
<li>任意进制字符串之间的转换<br><a href="#NK-jzzh">NK-进制转换</a></li>
</ol>
<hr>
<p><span id="1016"></span></p>
<h2 id="1016-Phone-Bills（日期类计算"><a href="#1016-Phone-Bills（日期类计算" class="headerlink" title="1016 Phone Bills（日期类计算)"></a>1016 Phone Bills（日期类计算)</h2><h3 id="1-题目大意-7"><a href="#1-题目大意-7" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定固定格式的日期<code>mm:dd:hh:mm</code>计算各个时间的差值，以及每个时间段有不同的费率，计算总的账单费用. </p>
<h3 id="2-学习要点-1"><a href="#2-学习要点-1" class="headerlink" title="2. 学习要点"></a>2. 学习要点</h3><p>1.数据结构设计<br>因为输入是给定一个个 call 序列，所以便于存储，也以每个 call 为单位，统一放在一个数组里，按照名字、时间排序，计算的时候，只要考虑 i 和 i-1 前后两个元素是否有同一个 name 以及 status 一个为 0 一个为 1 即可. </p>
<pre><code class="lang-cpp">struct node {
    string name;
    int status, month, time, day, hour, minute;
};

bool cmp(node a, node b) {
    return a.name != b.name ? a.name &lt; b.name : a.time &lt; b.time;
}
</code></pre>
<p>2.日期差值计算<br>直接”01:05:02:24“-”01:04:23:59“ 难以计算，每个小时还有不同的费率，所以 <strong>统一从本月 0 天 0 点开始计算</strong>，以<code>dd:hh:mm</code>格式再相减即可，隔天的情况则加上这一整天</p>
<pre><code class="lang-cpp">double billFromZero(node call, int *rate) {
    double total;
    total = rate[call.hour];  //本小时的费用
    total += call.minute + rate[24] * 60 * call.day;  //从本月第 0 天到今天
    for (int i = 0; i &lt; call.hour; i++)
        total += rate[i] * 60;  //本天内 0 点到现在累加
    return total / 100.0;
}
</code></pre>
<hr>
<h2 id="1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）"><a href="#1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）" class="headerlink" title="1018 Public Bike Management（图最短路径 Dijkstra + DFS）"></a>1018 Public Bike Management（图最短路径 Dijkstra + DFS）<span id="1018"></span></h2><p>图例经过 Dijkstra 之后的结果</p>
<pre><code class="lang-cpp">dis[1] = 1      pre[1] = {0}
dis[2] = 1      pre[2] = {0}
dis[3] = 2      pre[3] = {1, 2}
</code></pre>
<hr>
<p><span id="1020"></span></p>
<h2 id="1020-Tree-Traversals-已知后序和中序，转前序-层序"><a href="#1020-Tree-Traversals-已知后序和中序，转前序-层序" class="headerlink" title="1020 Tree Traversals (已知后序和中序，转前序/层序)"></a>1020 Tree Traversals (已知后序和中序，转前序/层序)</h2><h3 id="1-输入格式"><a href="#1-输入格式" class="headerlink" title="1. 输入格式"></a>1. 输入格式</h3><pre><code>7
2 3 1 5 7 6 4
1 2 3 4 5 6 7
</code></pre><h3 id="2-分析-4"><a href="#2-分析-4" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>和手动模拟差不多，找到根节点 (pre 的第一个，post 的最后一个) -&gt; 找到左右两段的端点，分别作为左右子树 -&gt; 递归重复. 关键在于递归的写法，端点的寻找. </p>
<h3 id="3-个人代码-5"><a href="#3-个人代码-5" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><code>level</code> 的作用即按照 <code>index</code> 存储，利用 2n+1 2n+2 的公式可以定位左右孩子，而索引的顺序恰好是层序遍历的顺序（具体第几层不知道）<br>转为前序遍历，只需在 pre 递归前打印 root 即可</p>
<pre><code class="lang-cpp">vector&lt;int&gt; in, post, level(100000, -1);

void pre(int root, int start, int end, int index){  
    //start end 都是相对于中序序列, 但是 root 是相对于 post 序列的！
    if(start &gt; end) return;
    level[index] = post[root];
    int i = start;
    while (i &lt; end &amp;&amp; in[i] != post[root]) i++;  //找到中序 in 序列中的根节点
    int left_size = i-start, right_size = end-i;
    pre(root-right_size-1, start, i-1, index*2+1);  //此 root 即为左孩子节点，可以确定为 index*2+1
    pre(root-1, i+1, end, index*2+2);
    //找到根节点 i，左子树 start ~ i-1, 右子树 i+1 ~ end
}
pre(n-1, 0, n-1, 0);
</code></pre>
<h3 id="4-类题"><a href="#4-类题" class="headerlink" title="4. 类题"></a>4. 类题</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024" target="_blank" rel="noopener">PTA-1086</a>（已知前序和中序遍历，求后序遍历）<br>给出用栈进行中序遍历的过程，求后序遍历. 有一个隐含条件，push 的顺序即为前序遍历，相对于已知 pre 和 in，求 post，同样找 root, start, end 即可. </p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200" target="_blank" rel="noopener">PTA-1138</a> (已知中序和前序遍历, 求后序遍历的第一个数字)<br>思路一样, 后序遍历是左右根, 因此有左边就只 post 递归左边, 没有左边才递归右边.</p>
<pre><code class="lang-C++">int pre[50001], in[50001], n, fir;

void post(int root, int start, int end){
    if(start == end){
        fir = start;
        return;   //只有一个节点
    }
    int i = start;
    while(i &lt;= end &amp;&amp; pre[root] != in[i]) i++;  //找到 in 序列中对应的 i

    if(i &gt; start)
        post(root+1, start, i-1);   //左边有就往左边遍历
    else
        post(root+1, i+1, end);

}
</code></pre>
<hr>
<p><span id="1021"></span></p>
<h2 id="1021-Deepest-Root-求树中最长的路径，DFS，连通分量"><a href="#1021-Deepest-Root-求树中最长的路径，DFS，连通分量" class="headerlink" title="1021 Deepest Root (求树中最长的路径，DFS，连通分量)"></a>1021 Deepest Root (求树中最长的路径，DFS，连通分量)</h2><h3 id="1-题目大意-8"><a href="#1-题目大意-8" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出n个结点（1~n）之间的n条边，问是否能构成一棵树，如果不能构成则输出它有的连通分量个数；如果能构成一棵树，输出能构成最深的树的高度时，树的根结点. 如果有多个，按照从小到大输出. </p>
<h3 id="2-分析-5"><a href="#2-分析-5" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>连通分量的个数：基本套路，一次 DFS 走完一个连通分量，统计循环中 DFS 开启的次数即可<br>本题关键在于，两次 DFS 即可求出所有最远端点（即所有最长路径中的所有端点）如果是一棵树的话，线段无非是两个端点，第一次 DFS 能找到一端，在这些最远端点中（可能有多个同样最远的，可能只有一个最远的）随便选一个作为起点，再来一次 DFS，即可找到另一端的最远端点. </p>
<h3 id="3-个人代码-6"><a href="#3-个人代码-6" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856" target="_blank" rel="noopener">PTA-1003</a></p>
<pre><code class="lang-cpp">void dfs(int node, int height) {
    if(height &gt; maxheight) {
        temp.clear();
        temp.push_back(node);
        maxheight = height;
    } else if(height == maxheight){
        temp.push_back(node);
    }
    visit[node] = true;
    for(int i = 0; i &lt; v[node].size(); i++) {
        if(visit[v[node][i]] == false)
            dfs(v[node][i], height + 1);
    }
</code></pre>
<h3 id="4-做题-Tips"><a href="#4-做题-Tips" class="headerlink" title="4. 做题 Tips"></a>4. 做题 Tips</h3><ol>
<li>本题不用考虑权重，所以无需开一个二维数组用邻接矩阵存储<br><code>e[10010][10010]; e[a]=e[b]=weight;</code><br>只需使用邻接表，把和自己直接相连的点存起来即可<br><code>v[node][i]; resize(n+1);</code><br><br></li>
<li>DFS 基本套路<pre><code class="lang-cpp"> dfs(int node, ...){   //遍历过程中顺带做其它操作
     visit[node] = true;
     for 与本点直接相连的 i:
         if(!visit[i])
             dfs(i, ...)
 }
</code></pre>
</li>
</ol>
<hr>
<p><span id="1102"></span></p>
<h2 id="1102-Invert-a-Binary-Tree-翻转二叉树"><a href="#1102-Invert-a-Binary-Tree-翻转二叉树" class="headerlink" title="1102 Invert a Binary Tree (翻转二叉树)"></a>1102 Invert a Binary Tree (翻转二叉树)</h2><h3 id="1-题目大意-9"><a href="#1-题目大意-9" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定一棵二叉树，先翻转好，输出层序遍历和中序遍历</p>
<h3 id="2-分析-6"><a href="#2-分析-6" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>可以写一个 invert 函数，交换本节点左右元素，然后对左右孩子递归即可. </p>
<pre><code class="lang-cpp">struct node{
    int left=-1, right=-1;  //-1 表示 NULL
};

void invert(int r){
    int a = v[r].left, b = v[r].right;
    if(a == -1 &amp;&amp; b == -1)
        return;
    v[r].left = b;
    v[r].right = a;
    if(v[r].left != -1) invert(v[r].left);
    if(v[r].right != -1) invert(v[r].right);
}
</code></pre>
<p>也可以不用写，正常遍历即可，只是先遍历右孩子，再遍历左孩子即可. </p>
<pre><code class="lang-cpp">//层序遍历标准模式：
void level(int r){
    queue&lt;int&gt; q;
    q.push(r);
    while (!q.empty()){
        r = q.front();
        q.pop();
        // if(q.empty()) break;
        le_ans.push_back(r);
        if(v[r].left != -1) q.push(v[r].left);
        if(v[r].right != -1) q.push(v[r].right);
    }
}
</code></pre>
<h3 id="3-坑点："><a href="#3-坑点：" class="headerlink" title="3. 坑点："></a>3. 坑点：</h3><ol>
<li>一般的题，都要考虑元素可能有重复，可能不按顺序. 本题使用    <code>mark</code>数组确定<code>root</code>是最好的方式</li>
<li><code>queue</code>和一般的<code>vector</code>有本质的不同，不能用迭代器遍历，不能索引，只能通过<code>front(), back()</code>访问. <code>quque</code>进行<code>pop(),front()</code>等操作时，一定要检查<code>q.empty()</code></li>
<li>当<code>queue</code>中只有一个元素时，<code>pop()</code>后，在访问<code>front()</code>可能会出现异常数字</li>
</ol>
<hr>
<p><span id="1040"></span></p>
<h2 id="1040-Longest-Symmetric-String-求最长对称子串-DP"><a href="#1040-Longest-Symmetric-String-求最长对称子串-DP" class="headerlink" title="1040 Longest Symmetric String (求最长对称子串 DP)"></a>1040 Longest Symmetric String (求最长对称子串 DP)</h2><h3 id="1-题目大意-10"><a href="#1-题目大意-10" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定一个字符串，找到最长的、对称的子串，输出长度<br>比如<code>Is PAT&amp;TAP symmetric?</code> 输出 11, 即<code>s PAT&amp;TAP s</code>的长度</p>
<h3 id="2-分析-7"><a href="#2-分析-7" class="headerlink" title="2. 分析"></a>2. 分析</h3><ol>
<li><p>基本递归的思路，大问题拆成小问题，拆成一个已知条件下的具体问题. 对于 子串/子序列 问题，要么用 <code>dp[i][j]</code>表示 i 和 j 的子串，要么用 <code>dp[i]</code>表示 0 到 i 之间的子串.</p>
</li>
<li><p>本题要求每一对<code>dp[i][j]</code>就要已知<code>dp[i+1][j-1]</code>, 再根据<code>str[i]</code>和<code>str[j]</code>来判断本段是否对称, 复杂问题被简化, 逐层逐层抛弃.</p>
</li>
<li><p>dp 的另外一个关键就在于初始化, 本题将所有<code>dp[i][i]</code>和相邻相等的所有<code>dp[i][i-1]</code>赋值为 1</p>
</li>
<li><p>本题一个难点在于, 普通的 dp 都可以从序列开头递归即可, 本题要根据子串的长度, 从短到长进行循环, 从中沉淀出最长的 length. 即区间 DP 的基本思路：区间长度作为最外层循环，端点作为内层循环.</p>
</li>
</ol>
<h3 id="3-个人代码-7"><a href="#3-个人代码-7" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344" target="_blank" rel="noopener">PTA-1040</a></p>
<pre><code class="lang-c++">for (int L = 3; L &lt;= len; ++L) {   //线段长度由小到大
        for (int i = 0; i &lt; len - L + 1; ++i) {  //能够到达的最右端点
            int j = i + L - 1;  //本次 i 对应的右端点 j
            if(str[i] == str[j] &amp;&amp; dp[i+1][j-1]){  //更新dp
                dp[i][j] = 1;
                ans = L;
            }
        }
    }
</code></pre>
<hr>
<p><span id="1045"></span></p>
<h2 id="1045-Favorite-Color-Stripe-最长不下降子序列-DP"><a href="#1045-Favorite-Color-Stripe-最长不下降子序列-DP" class="headerlink" title="1045 Favorite Color Stripe (最长不下降子序列 DP)"></a>1045 Favorite Color Stripe (最长不下降子序列 DP)</h2><h3 id="1-题目大意-11"><a href="#1-题目大意-11" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出m中颜色作为喜欢的颜色（同时也给出顺序），然后给出一串长度为L的颜色序列，现在要去掉这个序列中的不喜欢的颜色，然后求剩下序列的一个子序列，使得这个子序列表示的颜色顺序符合自己喜欢的颜色的顺序，不一定要所有喜欢的颜色都出现.<br>1 - N 表示 N 种颜色, 比如给出 2 3 1 5 6 表示自己喜欢的颜色序列</p>
<h3 id="2-分析-8"><a href="#2-分析-8" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>在原串中要找出符合 2 3 1 5 6 顺序的所有子串, 可能需要多层循环遍历, 还要用额外数组 tmp 临时记录, 数据难以比较和判断, 很麻烦. 所以考虑转化成有序数组, 一一对应成 1 2 3 4 5, 通过比大小即可判断, 等价于转化成一个<strong>最长不下降子序列</strong>问题.</p>
<p>维护单调数组 dp, <code>dp[i]</code>表示从 0 - i 最长不下降子序列的长度, 可以 DP 的精髓就在于, 本位置 i 对应的<code>dp[i]</code>可以由前面的<code>dp[0]</code> — <code>dp[i-1]</code> 直接推出.</p>
<p>举例:</p>
<pre><code>i  2 1 5 3 6 4 8 9 7
dp 1 1 2 2 3 3 4 5 4
j  2 1 5 3 6 4 8 9 7
</code></pre><p>此过程中沉淀出的 maxn 就是 5</p>
<h3 id="3-个人代码-8"><a href="#3-个人代码-8" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><pre><code class="lang-c++">int book[201], a[10001], dp[10001];
//dp[i]内存储的是, 从 0 到 i 为止最长的长度, 与 book 无关

int main(){
    int n, m, l, tmp, maxn = -1;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= m; ++i) {  //颜色为 1-n 将颜色序列映射为 idx 递增序列
        cin &gt;&gt; tmp;
        book[tmp] = i;
    }
    cin &gt;&gt; l;
    int num = 0;
    for (int i = 0; i &lt; l; ++i) {  //关键一步，把所有颜色转化为序号，依次存入 a 中
        cin &gt;&gt; tmp;
        if(book[tmp] &gt;= 1){
            a[num++] = book[tmp];  //a 存储 idx
        }
    }
    for (int i = 0; i &lt; num; ++i) {   //不喜欢的颜色直接忽略了,不计入考察范围
        dp[i] = 1;   //每次初始赋值为 1, 检查 0-i
        for (int j = 0; j &lt; i; ++j) {
            if(a[i] &gt;= a[j]){   //以 a 为评判标准, 大于等于就能做下一步
                dp[i] = max(dp[i], dp[j]+1);
                //核心思想，已知0 ~ i-1 的最大值，新来的 i 最多比0 ~ i-1 多 1
            }
        }
        maxn = max(maxn, dp[i]);
    }
    cout &lt;&lt; maxn;
    return 0;
}
</code></pre>
<hr>
<p><span id="T4861"></span></p>
<h2 id="TK-4861-最原始的最长不下降子序列-DP"><a href="#TK-4861-最原始的最长不下降子序列-DP" class="headerlink" title="TK 4861 最原始的最长不下降子序列 DP"></a>TK 4861 最原始的最长不下降子序列 DP</h2><h3 id="1-题目大意-12"><a href="#1-题目大意-12" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>输入输出样例</p>
<pre><code>7
3 7 2 5 6 3 8
-----
4
</code></pre><h3 id="2-个人代码-1"><a href="#2-个人代码-1" class="headerlink" title="2.个人代码"></a>2.个人代码</h3><p>核心判断 <code>if(v[j] &gt; v[i]) dp[j] = max(dp[j], dp[i]+1)</code> 两层循环, 对于每个 i, 从 i 之后开始遍历, 比它大则一定可以在它的 dp[i] 基础上 +1.</p>
<pre><code class="lang-cpp">int main(){
    int n, max_len=-1;
    cin &gt;&gt; n;
    vector&lt;int&gt; v(n), dp(n);  // dp[i]表示 0 ~ i 目前最长的不下降序列长度
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; v[i];
        dp[i] = 1;
    }
    for (int i = 0; i &lt; n; ++i) {
        for (int j = i; j &lt; n; ++j) {   // 从 i 之后开始遍历
            if(v[j] &gt; v[i])
                dp[j] = max(dp[j], dp[i]+1);
            max_len = max(max_len, dp[j]);  // 沉淀出最大的长度
        }
    }
    cout &lt;&lt; max_len;
    return  0;
}
</code></pre>
<hr>
<p><span id="1068"></span></p>
<h2 id="1068-Find-More-Coins-01-背包问题-DP"><a href="#1068-Find-More-Coins-01-背包问题-DP" class="headerlink" title="1068 Find More Coins (01 背包问题 DP)"></a>1068 Find More Coins (01 背包问题 DP)</h2><h3 id="1-题目大意-13"><a href="#1-题目大意-13" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>用n个硬币买价值为m的东西，输出使用方案，使得正好几个硬币加起来价值为m. 从小到大排列，输出最小的那个排列方案</p>
<h3 id="2-尝试-DFS"><a href="#2-尝试-DFS" class="headerlink" title="2. 尝试(DFS)"></a>2. 尝试(DFS)</h3><p>本题可以采用递归方案, DFS 递归到底, 直到刚好<code>target==0</code>即可, 类似于二叉树的寻找路径和. 但是某个测试点会超时.</p>
<p>核心代码(DFS 递归):</p>
<pre><code class="lang-c++">bool sear(int st, int target){   //搜索 st ~ n, 每次从 st 搜到末位
    if(0 == target)
        return true;
    for (int i = st; i &lt; n; ++i) {
        if(target &lt; a[i])   //后面的面额只会越来越大,不用搜了(剪枝)
            return false;
        tmp.push_back(a[i]);
        if (sear(i+1, target-a[i]))  //target减去当前,大目标拆成小目标
            return true;   //找到一个为 true 就不用再搜了,返回
        else tmp.pop_back();  //sear()==false 表示走不通, pop出来换下一个
    }
    return false;
}

sort(a, a+n);  //从小到大排序, 便于输出最小的方案
if(a[0] &gt; m){ printf(&quot;No Solution\n&quot;); return 0; } //面额太大,付不了小钱

for (int i = 0; i &lt; n; ++i) {  //逐个作为起点进行搜索
    tmp.clear();
    if(sear(i, m))
        break;
}
</code></pre>
<h3 id="3-0-1背包问题-DP"><a href="#3-0-1背包问题-DP" class="headerlink" title="3. 0-1背包问题(DP)"></a>3. 0-1背包问题(DP)</h3><p>给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi . </p>
<p>问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？<br>DP 的题还是要用 DP 来做, 关键在于搞清楚每一个数组的作用</p>
<p>🎒背包问题的经典转移公式</p>
<pre><code class="lang-c++">if(j &gt;= w[i])
    dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]);
else
    dp[i][j] = dp[i-1][j];  

//面对这个 i 物品, 不拿(或装不下), 就等同于 i-1 的情况
</code></pre>
<p><code>dp[i][j]</code> 表示 在面对第 i 件物品，且背包容量为 j 时所能获得的最大价值<br><code>dp[i-1][j-w[i]]+v[i]</code>则是容量空出<code>w[i]</code>的情况下( i-1表示回溯一个序号), 装入<code>v[i]</code>所能得到的价值.</p>
<p><a href="#T21802">👆最基本背包: 采药🌿</a></p>
<h3 id="4-正解-DP"><a href="#4-正解-DP" class="headerlink" title="4. 正解(DP)"></a>4. 正解(DP)</h3><pre><code>8 9
5 9 8 7 2 3 4 1
</code></pre><pre><code>1 3 5
</code></pre><pre><code class="lang-c++">int dp[101], choice[10001][101], w[10001];
//dp[j] 表示容量为 j 的时候, 最多能装多少钱数; w为每个硬币的面额
//choice[i][j]=true 表示总目标钱数为 j 时, i 可以作为一个选择
</code></pre>
<p>本题不是求最大价值, 只要求刚好装满, 只需要加一个判断<code>if(dp[m] != m)</code>, 然后以 m 为目标, 添加所有 choice 筛选的 [<strong>总目标钱数为 m 时, 可以作为一个选择</strong>] 的序列</p>
<p>本题的判断精髓就在这一句<code>if(dp[j] &lt;= dp[j-w[i]] + w[i])</code> 含义就是, 选择 w[i] 之后, 也能凑得和<code>dp[j]</code>之前 <strong>一样的, 甚至更多的</strong> 钱数.</p>
<p>本题实际发挥作用的时候, 小于号<code>&lt;</code>实际发挥的作用就是初始化, 让<code>dp[j]</code>从0变成一个数值, 比如<code>dp[9]=9</code>, 9 的面额直接满足; 等于号<code>=</code>实际发挥的作用就是寻找新的路径, 更新<code>choice[i][j]</code> 让<code>1 3 5</code>也组成进来.</p>
<p>比如, i=5 的时候, w[i]=4 已经更新了 dp[9]=9, dp[5]=5, 此时 j 从 m 遍历递减, 又从 9 开始, 有<code>dp[9] = dp[5] + w[i]</code>, 就把 i=5, 即 w[i]=4 添加进<code>choice[9][5] = true</code>, 作为路径之一</p>
<pre><code class="lang-c++">sort(w + 1, w + n + 1, cmp);  //从大的面额找起
for (int i = 1; i &lt;= n; ++i) {
    for (int j = m; j &gt;= w[i]; --j) {    //容量从 m 递减,直到比 w[j] 小则装不下,忽略
        if(dp[j] &lt;= dp[j-w[i]] + w[i]){
            choice[i][j] = true;
            dp[j] = dp[j-w[i]] + w[i];
        }
    }
}
if(dp[m] != m) cout &lt;&lt; &quot;No Solution&quot;;
else{
    int v = m, index = n;  //v 表示目标容量, n 表示初始序号在末尾(从最小的选起)

    while (v &gt; 0){
        if(choice[index][v]){  //目标为 v 的时候, w[index] 可以作为选项
            arr.push_back(w[index]);
            v -= w[index];
        }
        index--;
    }
    //输出 arr
}
</code></pre>
<h3 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h3><p>一道基础的背包问题, 居然思考了我一整个下午, 算法基础真的薄弱. 鉴于网上的题解要么不够大佬, 代码不够最优; 要么太过于大佬, 解释得很简略. 于是我吧最大佬的代码, 用最清楚的语言解释, 是对自己思路的一个锻炼, 也希望帮助后来的萌新们.</p>
<hr>
<p><span id="NK-zxyps"></span></p>
<h2 id="NK-最小邮票数-动态规划，特定值子序列和"><a href="#NK-最小邮票数-动态规划，特定值子序列和" class="headerlink" title="NK 最小邮票数 (动态规划，特定值子序列和)"></a>NK 最小邮票数 (动态规划，特定值子序列和)</h2><h3 id="1-题目大意-14"><a href="#1-题目大意-14" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>题目描述<br>    有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。     如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。<br>输入描述:<br>    有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。<br>输出描述:<br>      对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。<br>输入</p>
<pre><code>10
5
1 3 3 3 4
</code></pre><p>输出</p>
<pre><code>3
</code></pre><h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><p><a href="https://github.com/cowarder/Algorithms/blob/master/%E7%89%9B%E5%AE%A2/%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0.cpp" target="_blank" rel="noopener">牛客-最小邮票数</a></p>
<hr>
<p><span id="1044"></span></p>
<h2 id="1044-Shopping-in-Mars-特定值子序列和-二分查找"><a href="#1044-Shopping-in-Mars-特定值子序列和-二分查找" class="headerlink" title="1044 Shopping in Mars (特定值子序列和, 二分查找)"></a>1044 Shopping in Mars (特定值子序列和, 二分查找)</h2><h3 id="1-题目大意-15"><a href="#1-题目大意-15" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>求一串的数字中连续的一段，使得这个连续的段内数字的和恰好等于所期望的值m. 如果不能找到恰好等于，就找让自己付出最少的价格（总和必须大于等于所给值）的那段区间, 求所有可能的结果.<br>简而言之, 就是找一个连续子序列, 恰好等于 target</p>
<h3 id="2-个人代码-2"><a href="#2-个人代码-2" class="headerlink" title="2. 个人代码"></a>2. 个人代码</h3><p>因为给定的金币序列是乱序的, 这题一开始没想到可以二分法. 其实题目要求的是连续的子段, 那么就可以逐级叠加求<code>sum</code>, <code>a[j] - a[i-1]</code>即是 i~j 这一段的子段和. 而这个逐级叠加的<code>sum</code>数组, 就是一个完美的递增序列.</p>
<p>注意解题技巧, 需要多个参数时, 可以采用<code>int &amp;j, int &amp;temp_sum</code>引用传参.</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
using namespace std;

vector&lt;int&gt; sum, ans;
int n, m;

// 从 i 开始, 以 n 结尾的序列, 二分查找
// 目标: 找到右端点, 刚好比左端点大 m
void search(int i, int &amp;j, int &amp;temp_sum){
    int left = i, right = n;
    int target = sum[left-1] + m;
    while (left &lt; right){
        // 保留右侧的二分查找, 不求找到而退出
        // 最后让 left==right 时退出, 此时是比 target 大的最小数
        // 因为 mid 小了的时候, 总是舍弃左端点, mid 大了的时候, 右端点被保留
        int mid = (left+right)/2;
        if(sum[mid] &lt; target)
            left = mid + 1;
        else
            right = mid;
    }
    j = right;
    temp_sum = sum[right] - sum[i-1];
}

int main(){
    cin &gt;&gt; n &gt;&gt; m;
    sum.resize(n+1);
    sum[0] = 0;
    for (int i = 1; i &lt;= n; ++i) {  //转化为递增序列, 得以应用二分, 提高效率
        cin &gt;&gt; sum[i];
        sum[i] += sum[i-1];
    }
    int min_ans = sum[n];  //求比 m 大的最小和
    for (int i = 1; i &lt;= n; ++i) {
        int j=0, temp_sum=0;  //仅仅作为参数传回来而已
        search(i, j, temp_sum);
        if(temp_sum &lt; m) continue;
        else{
            if(temp_sum &lt; min_ans){
                min_ans = temp_sum;
                ans.clear();
                ans.push_back(i);
                ans.push_back(j);
            }
            else if (temp_sum == min_ans){
                ans.push_back(i);
                ans.push_back(j);
            }
        }
    }
    for (int i = 0; i &lt; ans.size(); i += 2) {
        cout &lt;&lt; ans[i] &lt;&lt; &quot;-&quot; &lt;&lt; ans[i+1] &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<hr>
<p><span id="1085"></span></p>
<h2 id="1085-Perfect-Sequence-二分查找-upper-bound-双指针"><a href="#1085-Perfect-Sequence-二分查找-upper-bound-双指针" class="headerlink" title="1085 Perfect Sequence (二分查找, upper-bound, 双指针)"></a>1085 Perfect Sequence (二分查找, upper-bound, 双指针)</h2><h3 id="1-题目大意-16"><a href="#1-题目大意-16" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>设这个数列中的最大值是M，最小值是m，如果M &lt;= m * p，则称这个数列是完美数列. 现在给定一个序列, 求满足完美序列的最长子序列长度</p>
<h3 id="2-二分法"><a href="#2-二分法" class="headerlink" title="2.二分法"></a>2.二分法</h3><p>本题可以应用 upper_bound 来查找, 既然要求满足最大的<code>max &lt;= p*min</code>, 那么找到第一个<code>max &gt; p*min</code>即可, 即找到第一个大于target 的元素.</p>
<p><strong>upper-bound 代码</strong></p>
<pre><code class="lang-c++">int bin_sear_upper(int left, int right, int target){
    int mid;
    while (left &lt; right){
        mid = (left+right)/2;
        if(a[mid] &gt; target)
            right = mid;
        else
            left = mid + 1;
    }
    return right;
}
</code></pre>
<p>关键点 1: <code>left &lt; right</code>到最后必然会夹出 left==right 返回即可.</p>
<p>关键点 2: 先判断<code>&gt;</code>, 让<code>right = mid</code>目的是尽可能保留大数,<code>left = mid + 1</code>小数不保留无所谓.</p>
<p><strong>lower-bound 代码</strong></p>
<pre><code class="lang-c++">if(a[mid] &gt;= target)
    right = mid;
else
    left = mid + 1;
</code></pre>
<p>只需换为<code>&gt;=</code>即可, 其他完全一样, 也是保大.</p>
<p>比如 3 4 5 5 7 8 8 8 9, target 为 8.<br>upper_bound 找到的为 3 4 5 5 7 [8] 8 8 9, lower_bound 找到的为 3 4 5 5 7 8 8 8 [9].</p>
<p><strong>普通的查找定值</strong><br><code>if(a[mid]==target)</code>, 需要<code>left &lt;= right</code>作为条件, 找不到就返回-1</p>
<pre><code class="lang-cpp">while(low &lt;= high){
    int mid = (low + high)/2;
    if(array[mid] &lt; key)
        low = mid + 1;
    else if(array[mid] &gt; key)
        high = mid - 1;
    else
        return mid;
}
return -1;
</code></pre>
<p>这三种二分法基本可以涵盖所有二分查找的应用.</p>
<h3 id="3-个人代码-9"><a href="#3-个人代码-9" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><pre><code class="lang-c++">int search(int left, long long target){  // 寻找比 target 小的最大数 upper_bound
    int right = n-1, mid;
    if(a[right] &lt;= target){  //最大的比 target 小
        return right;
    }
    while (left &lt; right){
        mid = (left + right)/2;
        if(a[mid] &gt; target)
            right = mid;
        else
            left = mid + 1;
    }
    return right-1;  // 最后 left==right 找到的是第一个比 tar 大的数, -1 即可
}
</code></pre>
<p>应用的是 upper_bound, <code>right-1</code>即可得到满足<code>max &lt;= p*min</code>的最大数字.</p>
<h3 id="4-坑点-1"><a href="#4-坑点-1" class="headerlink" title="4. 坑点"></a>4. 坑点</h3><ol>
<li><code>段错误</code> 数组开的不够大, 递归调用过多</li>
<li><code>答案错误</code> 发现存在溢出, int 最大管到 $10^9$, 此题乘起来之后会超过, 要用 long long !</li>
</ol>
<h3 id="5-Two-points-双指针法"><a href="#5-Two-points-双指针法" class="headerlink" title="5. Two points 双指针法"></a>5. Two points 双指针法</h3><p>瞬间非常简单</p>
<pre><code class="lang-c++">    sort(v.begin(), v.end());
    int result = 0, temp = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + result; j &lt; n; j++) {  
        //result 已经是最长了, 之后的直接从 result 以上的找起
            if (v[j] &lt;= v[i] * p) {
                temp = j - i + 1;
                if (temp &gt; result)
                    result = temp;
            } else {
                break;
            }
        }
    }
    cout &lt;&lt; result;
</code></pre>
<p><img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://i.loli.net/2020/02/12/Buth7AGTcCpPonS.png" alt="效率对比差距明显" width="140" height="180"/></p>
<hr>
<p><span id="1029"></span></p>
<h2 id="1029-Median-找中位数-计数排序"><a href="#1029-Median-找中位数-计数排序" class="headerlink" title="1029 Median (找中位数 计数排序)"></a>1029 Median (找中位数 计数排序)</h2><h3 id="1-题目大意-17"><a href="#1-题目大意-17" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><hr>
<p><span id="1143"></span></p>
<h2 id="1143-Lowest-Common-Ancestor-最近的公共祖先"><a href="#1143-Lowest-Common-Ancestor-最近的公共祖先" class="headerlink" title="1143 Lowest Common Ancestor (最近的公共祖先)"></a>1143 Lowest Common Ancestor (最近的公共祖先)</h2><h3 id="1-题目大意-18"><a href="#1-题目大意-18" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定二叉搜索树 BST 的 pre 前序遍历, 再给定一对 U,V 求 U,V 的 LCA</p>
<h3 id="2-分析-9"><a href="#2-分析-9" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>本题有两个特殊条件, 一个是<code>BST</code>, 形式是<code>左边小右边大</code>, 一个是<code>前序遍历pre</code>, 对于数组形式的 pre 序列, 形式是<code>根左右</code>. 所以只需要 u,v 分别在 a 的两端, 一个比 a 大, 一个比 a 小, a 就是公共祖先. 当 <code>a==u || a==v 时</code>, 谁在前谁就是祖先</p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><pre><code class="lang-cpp">map&lt;int, bool&gt; mp;
int main() {
    int m, n, u, v, a;
    scanf(&quot;%d %d&quot;, &amp;m, &amp;n);
    vector&lt;int&gt; pre(n);
    for (int i = 0; i &lt; n; i++) {
        scanf(&quot;%d&quot;, &amp;pre[i]);
        mp[pre[i]] = true;
    }
    for (int i = 0; i &lt; m; i++) {
        scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
        for(int j = 0; j &lt; n; j++) {
            a = pre[j];
            if ((a &gt;= u &amp;&amp; a &lt;= v) || (a &gt;= v &amp;&amp; a &lt;= u)) break;
        } 
        if (mp[u] == false &amp;&amp; mp[v] == false)
            printf(&quot;ERROR: %d and %d are not found.\n&quot;, u, v);
        else if (mp[u] == false || mp[v] == false)
            printf(&quot;ERROR: %d is not found.\n&quot;, mp[u] == false ? u : v);
        else if (a == u || a == v)
            printf(&quot;%d is an ancestor of %d.\n&quot;, a, a == u ? v : u);
        else
            printf(&quot;LCA of %d and %d is %d.\n&quot;, u, v, a);
    }
    return 0;
}
</code></pre>
<hr>
<p><span id="1071"></span></p>
<h2 id="1071-Speech-Patterns-词频统计"><a href="#1071-Speech-Patterns-词频统计" class="headerlink" title="1071 Speech Patterns (词频统计)"></a>1071 Speech Patterns (词频统计)</h2><h3 id="1-题目大意-19"><a href="#1-题目大意-19" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定一行句子, 统计出现频率最高的 word. word 定义为仅包含<code>0-9 A-Z a-z</code>的连续串. 如果有相同词频, 就输出字典序最小的.</p>
<pre><code>Can1: &quot;Can a can can a can?  It can!&quot;
</code></pre><pre><code>can 5
</code></pre><h3 id="2-个人代码-3"><a href="#2-个人代码-3" class="headerlink" title="2. 个人代码"></a>2. 个人代码</h3><pre><code class="lang-cpp">map&lt;string, int&gt; m;  //会按照键的字典序排序

int main(){
    string str, t;
    int maxn=-1, i=0;
    getline(cin, str);

    for (auto &amp;c : str) {
        i++;
        if(isalnum(c)){
            t += tolower(c);
        }
        if(!isalnum(c) || i==str.length()){ //碰到间隙或者结尾时, 进行计数
            if(t.length()) m[t]++;
            t = &quot;&quot;;
        }
    }

    for(auto it=m.begin(); it!=m.end(); it++){
        if(it-&gt;second &gt; maxn){
            maxn = it-&gt;second;
            t = it-&gt;first;
        }
    }

    cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; maxn;

    return 0;
}
</code></pre>
<hr>
<p><span id="T21802"></span></p>
<h2 id="TK-21802-采药-最基础的容量-价值最大化-背包问题-DP"><a href="#TK-21802-采药-最基础的容量-价值最大化-背包问题-DP" class="headerlink" title="TK 21802  采药 (最基础的容量-价值最大化, 背包问题, DP)"></a>TK 21802  采药 (最基础的容量-价值最大化, 背包问题, DP)</h2><h3 id="1-题目大意-20"><a href="#1-题目大意-20" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p><strong>输入</strong><br>输入的第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目. 接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值.<br><strong>输出</strong><br>输出包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值.</p>
<pre><code>70 3
71 100
69 1
1 2
------
3
</code></pre><h3 id="2-方法一"><a href="#2-方法一" class="headerlink" title="2.方法一"></a>2.方法一</h3><p>本题只需使用最最经典原始的背包问题转移公式即可</p>
<pre><code class="lang-cpp">int v[110], t[110], dp[110][1010];  // dp[i][j] 表示面对第 i 个,容量为 j 时 的最大价值

int main(){
    int T, m;   // T 总时间, m 个药草
    cin &gt;&gt; T &gt;&gt; m;

    for (int i = 1; i &lt;= m; ++i) {
        cin &gt;&gt; t[i] &gt;&gt; v[i];
    }
    for (int i = 1; i &lt;= m; ++i) {
        for (int j = 0; j &lt;= T; ++j) {
            if(j &gt;= t[i])
                dp[i][j] = max(dp[i-1][j-t[i]] + v[i], dp[i-1][j]);
            else
                dp[i][j] = dp[i-1][j];  // i-1 表示不拿这一个草药, 相当于没碰见前
        }
    }
    cout &lt;&lt; dp[m][T];

    return  0;
}
</code></pre>
<p>坑点: 一定要注意 dp 数组的范围, 1010 不能开小了</p>
<h3 id="3-方法二"><a href="#3-方法二" class="headerlink" title="3.方法二"></a>3.方法二</h3><p>一维数组 dp, 无需每一个容量面对每一个物品, 只需设定 dp[x] 表示容量为 x 时的最大价值. 状态转移方程:<br><code>dp[v] = max (dp[v] , dp[v - t[i]] + v[i])</code><br>其中 t[i] 表示草药的采集时间 ， v[i] 指草药的价值.</p>
<pre><code class="lang-cpp">const int maxv=1010,maxn=110;
int dp[maxv], t[maxn], v[maxn];
...
    for(int i=1;i&lt;=n;++i)
        for(int x = T; x &gt;= t[i]; --x)  //从 T 开始遍历
            dp[x] = max(dp[x], dp[x-t[i]] + v[i]);  //装 or 不装

    for(int x = 0; x &lt;= T; ++x)
        if(dp[x] &gt; max)
            max = dp[x];
...
}
</code></pre>
<hr>
<p><span id="H1130"></span></p>
<h2 id="H1130-分成两个尽可能接近的子数组-背包问题-DP"><a href="#H1130-分成两个尽可能接近的子数组-背包问题-DP" class="headerlink" title="H1130 分成两个尽可能接近的子数组 (背包问题 DP)"></a>H1130 分成两个尽可能接近的子数组 (背包问题 DP)</h2><h3 id="1-题目大意-21"><a href="#1-题目大意-21" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>小明班里要举行一次拔河比赛，班主任决定将所有人分为两队，每个人都必须参加. 两个队伍的人数之差不能超过1，并且两个队伍的体重之和<code>要尽可能相近</code>，当然相同是最好的了. 分别输出两个队伍的体重之和，按升序排序.</p>
<p>简而言之, 将一个数组分成两个尽可能接近的子数组.</p>
<h3 id="2-分析-10"><a href="#2-分析-10" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>有一系列元素, 让这些元素尽可能地接近一个目标值, 这就是典型的背包 DP 问题. 本题的关键在于, 只研究一个数组, 让它尽可能接近 sum/2 即可, 另一个就与它最接近.</p>
<h3 id="3-核心代码"><a href="#3-核心代码" class="headerlink" title="3. 核心代码"></a>3. 核心代码</h3><pre><code class="lang-cpp">int sum = 0;
int a[n+1];
for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i];
    sum += a[i];
}
vector&lt;int&gt; dp(sum);  //dp[i]表示容量为 i 时能装下的总量
fill(dp.begin(), dp.end(), 0);
for (int i = 1; i &lt;= n; i++){  //面对第 i 个的时候
    for (int j = sum/2; j &gt;= a[i]; j--){  //容量从目标开始减少
        dp[j] = max(dp[j], dp[j-a[i]] + a[i]); //标准转移公式
    }
}
int tmp = max(dp[sum/2], sum-dp[sum/2]);
printf(&quot;%d %d\n&quot;, sum-tmp, tmp);
</code></pre>
<p>此程序的目的, 就是给定一个 target=sum/2, 让元素通过各种组合, 去无限逼近 target.</p>
<p>对于<code>dp[j-a[i]] + a[i])</code>要理解清楚, 表示<code>已知</code>空出 a[i] 后的最大容量, 再加入 a[i] 看效果. 因为对于每一种容量, 不可能都会<code>恰好装满</code>, 所以 dp[5] 可能等于 3, 那么面对一个 4, dp[9] 就等于 3+4=7.</p>
<h3 id="4-记忆点"><a href="#4-记忆点" class="headerlink" title="4. 记忆点"></a>4. 记忆点</h3><ul>
<li><p>两层循环, 外层一件件物品遍历, <code>for (int i = 1; i &lt;= n; i++)</code>, 内层从目标容量递减 (容量是连续值) <code>for (int j = sum/2; j &gt;= a[i]; j--)</code>, 直到装不下为止.</p>
</li>
<li><p>转移公式<code>dp[j] = max(dp[j], dp[j-a[i]] + a[i]);</code>, 对应两种情况, <code>看见了 a[i] 但不装</code>, 和 <code>装下 a[i]</code></p>
</li>
<li><p>此处使用一位数组 dp, 和二维 dp 数组区别开</p>
</li>
</ul>
<hr>
<p><span id="1067"></span></p>
<h2 id="1067-Sort-with-Swap-0-i-贪心-元素归位"><a href="#1067-Sort-with-Swap-0-i-贪心-元素归位" class="headerlink" title="1067 Sort with Swap(0, i) (贪心, 元素归位)"></a>1067 Sort with Swap(0, i) (贪心, 元素归位)</h2><h3 id="1-题目大意-22"><a href="#1-题目大意-22" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定一个 0~n-1 的乱序序列, 每次只能用 0 与某个数交换, 求需要交换多少次才能归位.</p>
<pre><code>10
3 5 7 2 6 4 9 0 8 1
</code></pre><pre><code>9
</code></pre><h3 id="2-分析-11"><a href="#2-分析-11" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>基本思路: 把 0 当做哨兵, 根据 0 处在的位置 i , 每次让 0 与原本应处于 i 的那个数去交换. 如果 0 已经归位, 则顺次查找下一个不在本位的进行交换.</p>
<p>一开始的做法是, 维护原来的数组, 每次 for 循环遍历查找对应的那个数, 结果超时/出错.</p>
<p>本题巧妙之处在于, 由于数组是一个 0~n-1 的无重复数组, 不一定要保存值的数组, 而是保存一个索引的数组, 因为 swap 目的就是要交换位置, <code>交换索引</code>而已. 交换索引后, 不需要遍历查找对应数, 因为 a[0] 就是 0 所处在的位置index, 交换 a[0] 和 a[a[0]] 即可.</p>
<h3 id="3-个人代码-10"><a href="#3-个人代码-10" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p>一个 n 的 for 循环, 当 n 个都满足<code>a[i] != i</code>就结束</p>
<pre><code class="lang-cpp">vector&lt;int&gt; a(n);
for (int i = 0; i &lt; n; ++i) {
    cin &gt;&gt; t;
    a[t] = i;   // t 对应的索引
}

for (int i = 1; i &lt; n; ++i) {  //a[0] 即 0 对应的索引, 每次拿 0 交换
    while (a[0] != 0){
        swap(a[0], a[a[0]]);   //可以一直换 0 的索引
        cnt++;
    }
    if (a[i] != i){   //0 暂时归位,则判断当前 i 是否归位
        swap(a[0], a[i]);
        cnt++;
    }
}
</code></pre>
<hr>
<p><span id="1100"></span></p>
<h2 id="1100-Complete-Binary-Tree-判断完全二叉树-层序遍历"><a href="#1100-Complete-Binary-Tree-判断完全二叉树-层序遍历" class="headerlink" title="1100 Complete Binary Tree (判断完全二叉树, 层序遍历)"></a>1100 Complete Binary Tree (判断完全二叉树, 层序遍历)</h2><h3 id="1-题目大意-23"><a href="#1-题目大意-23" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定一棵二叉树, 判断是不是完全二叉树</p>
<pre><code>9
7 8
- -
- -
- -
0 1
2 3
4 5
- -
- -
</code></pre><h3 id="2-尝试层序遍历"><a href="#2-尝试层序遍历" class="headerlink" title="2.尝试层序遍历"></a>2.尝试层序遍历</h3><p>层序遍历分层输出: 添加一个<code>cur_len</code>表示本层目前的长度, <code>cur_len</code>通过<code>next_level</code>来维护, 每添加一个子节点进入队列, 就<code>next_level++</code>, 每 pop 一个节点, 就<code>cur_len--</code>. 直到<code>cur_len==0</code> 表示一层的结束, 可以做一个小结了.</p>
<pre><code class="lang-cpp">q.push(root);
    int next_level = 0, cur_len = 1, no=-1;
    vector&lt;int&gt; lev;
    lev.push_back(1);

    while (!q.empty()){
        no = q.front();
        cur_len--;  //本层减 1

        if(v[no].left != -1){
            next_level++;
            q.push(v[no].left);
        }
        if(v[no].right != -1){
            next_level++;
            q.push(v[no].right);
        }
        if(cur_len == 0){   //本层结束
            if(next_level) lev.push_back(next_level);
            else break;
            cur_len = next_level; //更新为下一层的长度
            next_level = 0;
        }
        q.pop();
    }
</code></pre>
<p>但是这个方法只能判断前几层是否满足 1, 2, 4, 8 的规律, 无法判断最后一层.</p>
<h3 id="3-正确解法"><a href="#3-正确解法" class="headerlink" title="3.正确解法"></a>3.正确解法</h3><p>递归出最大的下标值，完全二叉树一定把前面的下标充满： 最大的下标值 == 最大的节点数；不完全二叉树前满一定有位置是空，会往后挤： 最大的下标值 &gt; 最大的节点数.</p>
<pre><code class="lang-cpp">struct node{
    int left=-1, right=-1;
};
int maxn = -1, last;  //记录最大下标, 最后一个元素下标

void dfs(int nod, int index){
    if(index &gt; maxn){
        maxn = index;
        last = nod;
    }
    if(v[nod].left != -1)
        dfs(v[nod].left, index*2+1);
    if(v[nod].right != -1)
        dfs(v[nod].right, index*2+2);
}
dfs(root, 0);
if(maxn == n-1)
    cout &lt;&lt; &quot;YES &quot; &lt;&lt; last;
else
    cout &lt;&lt; &quot;NO &quot; &lt;&lt; root;
</code></pre>
<h3 id="4-坑点-2"><a href="#4-坑点-2" class="headerlink" title="4.坑点"></a>4.坑点</h3><p>注意会出现<code>段错误</code>, 一开始以为是数组开的不够大, 结果发现这个题真是犯了一个低级的错误，我开始用字符变量来输入，然而一个字符变量只能赋一个数字，所以如果数的数据有二位数，那么字符变量只能录入十位数字，或者就出错，出现段错误. 一定要用 string 然后 <code>stoi</code>, 不能用 char.</p>
<p>然后还有一种<code>运行时错误</code>, 想要通过 set 找到根节点, 不知道为什么错误.</p>
<pre><code class="lang-cpp">    {  ...
       s.insert(stoi(a));
       s.insert(stoi(b));
    }
   for (int i = 0; i &lt; n; ++i) {  //找到根节点
       if(s.find(i) == s.end()){
           root = i;
           break;
       }
   }
</code></pre>
<p>正确的方法应该是用数组进行标记, 找到 root.</p>
<pre><code class="lang-cpp">while (have[root] != 0) root++;
</code></pre>
<hr>
<p><span id="T1131"></span></p>
<h2 id="TK-1131-分梨"><a href="#TK-1131-分梨" class="headerlink" title="TK 1131 分梨"></a>TK 1131 分梨</h2><h3 id="1-题目大意-24"><a href="#1-题目大意-24" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>现在要把M个梨子放到N个盘子里面（我们允许盘子为空），有多少种分法？请注意，例如有三个盘子，我们将 5,1,1 和 1,1,5，视为同一种分法</p>
<h3 id="2-分析-12"><a href="#2-分析-12" class="headerlink" title="2.分析"></a>2.分析</h3><p>属于入门 DP, 掌握思想. 设 p（m,n）为有m个梨和n个盘子时的方案数，则可分情况讨论设计状态转移方程：</p>
<p>1：当 m &lt; n 时，则必有 n-m 个空盘子，因为盘子无顺序可言，可以忽略掉那 n-m 个空盘子, 则可推得 <code>p(m,n) = p(m,m)</code></p>
<p>2：当 m&gt;=n 时，则 <code>p(m,n) = p(m-n,n) + p(m,n-1)</code>, <code>p(m-n,n)</code> 表示 <strong>没有任何空盘子</strong>, 将所有盘子至少放一个梨子, <code>p(m,n-1)</code> 表示 <strong>至少有一个盘子为空</strong>, 多个盘子为空也包含在内.</p>
<p>3：最终递归的终极条件为，只有一个盘子或者没有梨</p>
<h3 id="个人代码"><a href="#个人代码" class="headerlink" title="个人代码"></a>个人代码</h3><pre><code class="lang-cpp">int Pear(int m, int n){
//    if(m == 1 || n == 1 || m == 0 || n == 0) // 注意 1 个梨子或者 0 个盘子, 不行, 因为可以不放
    if(n == 1 || m == 0)   //1 个盘子, 或者 0 个梨子, 一定为 1
        return 1;
    if(m &lt; n)
        return Pear(m , m);
    return Pear(m-n, n) + Pear(m, n-1);
}

int main(){
    int t, m, n;
    while (scanf(&quot;%d&quot;, &amp;t) != EOF){
        while (t--){
            cin &gt;&gt; m &gt;&gt; n;
            cout &lt;&lt; Pear(m, n) &lt;&lt; endl;
        }
    }
    return  0;
}
</code></pre>
<hr>
<p><span id="T1132"></span></p>
<h2 id="TK-1132-最长公共子序列-LCS-入门经典-DP"><a href="#TK-1132-最长公共子序列-LCS-入门经典-DP" class="headerlink" title="TK 1132 最长公共子序列 LCS (入门经典 DP)"></a>TK 1132 最长公共子序列 LCS (入门经典 DP)</h2><h3 id="1-题目大意-25"><a href="#1-题目大意-25" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>样例输入</p>
<pre><code>abcfbc abfcab
programming contest 
abcd mnp
</code></pre><p>样例输出</p>
<pre><code>4
2
0
</code></pre><h3 id="2-分析-amp-代码"><a href="#2-分析-amp-代码" class="headerlink" title="2.分析 &amp; 代码"></a>2.分析 &amp; 代码</h3><p>注意一个坑点, 下标一定要从 1 开始. 以及注意一下 scanf 读入字符串, 此题最好使用 char[] 数组.</p>
<pre><code class="lang-cpp">char a[110], b[110];  //string 无法读入

int dp[110][110];  //dp[i][j] 表示 A_i 和 B_j 之间的最长公共长度
// 注意坑点, 下标必须从 1 开始, 因为涉及 dp[i-1] 这种

int main(){
    while (scanf(&quot;%s %s&quot;, a+1, b+1) != EOF){  // 从 1 开始存储
        int lenA=1, lenB=1;
        while (a[lenA++] != &#39;\0&#39;);
        while (b[lenB++] != &#39;\0&#39;);
        lenA -= 2; lenB -= 2;

        for (int i = 1; i &lt;= lenA; ++i)
            for (int j = 1; j &lt;= lenB; ++j)
                if(a[i] == b[j])    // 遇到共同字符直接 +1
                    dp[i][j] = dp[i-1][j-1] + 1;
                else     //没有遇到取最大
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);

        cout &lt;&lt; dp[lenA][lenB] &lt;&lt; endl;
    }

    return  0;
}
</code></pre>
<p>附: 如果没有给定数据范围, 可以使用二维 vector 做 dp 数组</p>
<pre><code class="lang-cpp">int len1 = s1.length();
int len2 = s2.length();
vector&lt;vector&lt;int&gt;&gt;dp;
dp.resize(len1);
for (int i = 0; i &lt; len1; i++)
    dp[i].resize(len2);
</code></pre>
<hr>
<p><span id="T5578"></span></p>
<h2 id="TK-5578-最大约数和-DP"><a href="#TK-5578-最大约数和-DP" class="headerlink" title="TK 5578 最大约数和 (DP)"></a>TK 5578 最大约数和 (DP)</h2><h3 id="1-题目大意-26"><a href="#1-题目大意-26" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>[问题描述] 选取<code>和</code>不超过S的若干个不同的正整数，使得所有数的约数（不含它本身）之和最大. 输入一个正整数S输出最大的约数之和<br>[样例输入]<br>11<br>[样例输出]<br>9<br>[样例说明]<br>取数字4和6，可以得到最大值(1+2)+(1+2+3) = 9</p>
<h3 id="2-个人代码-4"><a href="#2-个人代码-4" class="headerlink" title="2.个人代码"></a>2.个人代码</h3><pre><code class="lang-cpp">int a[1005], dp[1005];   // dp[i] 表示 &lt;= i 的最大约数和

int main(){
    int s;
    cin &gt;&gt; s;
    for (int i = 1; i &lt;= s; ++i)
        for (int j = 1; j &lt;= i/2; ++j)
            if(i % j == 0) dp[i] += j; // 如果 j 是 i 的约数之一

    for (int i = 1; i &lt;= s; ++i) {
        for (int j = 1; j &lt;= i/2; ++j) {
            dp[i] = max(dp[i], dp[j] + dp[i-j]);  // 每一对不超过 s 的和都计算过
        }
    }
    cout &lt;&lt; dp[s];

    return  0;
}
</code></pre>
<hr>
<p><span id="T5579"></span></p>
<h2 id="TK-5579-环形石子合并-区间-DP"><a href="#TK-5579-环形石子合并-区间-DP" class="headerlink" title="TK 5579 环形石子合并 (区间 DP)"></a>TK 5579 环形石子合并 (区间 DP)</h2><h3 id="1-题目大意-27"><a href="#1-题目大意-27" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>石子合并问题的三种类型: 任意合并/相邻合并/环形合并. <a href="#https://blog.csdn.net/qq_40507857/article/details/81266843">详情链接👆</a><br><strong>环形合并</strong>: 在一个<code>圆形</code>操场的四周摆放着 n 堆石子. 现要将石子有次序地合并成一堆. 规定每次只能把<code>相邻</code>的 2 堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分.<br>试设计一个算法，计算出将n堆石子合并成一堆的最小得分和最大得分.</p>
<h3 id="2-关键思路"><a href="#2-关键思路" class="headerlink" title="2.关键思路"></a>2.关键思路</h3><pre><code class="lang-cpp">const int maxn = 210;  // a1...an a1...an 复制为两个
int sum[maxn][maxn], min_dp[maxn][maxn], max_dp[maxn][maxn];
//sum[i][j] 表示 i 到 j 的石子总和,  dp[i][j] 表示 i 到 j 的总代价
</code></pre>
<p>从 i 到 j 合并的代价/得分为: i 到 j 的总石子数 + i~k 的得分 + k+1~j 的得分<br>对于区间DP，我们通常是一个循环枚举区间的长度，一个循环枚举区间的左端点.<br>遍历方式: 三层遍历, 区间长度 -&gt; 区间起点 -&gt; 区间分割点</p>
<h3 id="3-个人代码-11"><a href="#3-个人代码-11" class="headerlink" title="3.个人代码"></a>3.个人代码</h3><pre><code class="lang-cpp">int main(){
    int n, x, min_sc=inf, max_sc=0;
    cin &gt;&gt; n;
    fill(min_dp[0], min_dp[0] + maxn*maxn, inf);  // 默认距离为最大, 方便取 min
    for (int i = 1; i &lt;= n; ++i) {
        cin &gt;&gt; x;
        sum[i][i] = sum[i+n][i+n] = x;
        min_dp[i][i] = min_dp[i+n][i+n] = 0;
    }

    for (int len = 1; len &lt; n; ++len) {  //区间长度
        for (int i = 1; i &lt;= 2*n &amp;&amp; i+len &lt;= 2*n; ++i) {    //区间起点
            int j = i+len;                  //区间终点
            for (int k = i; k &lt; j; ++k) {  //区间分割点
                sum[i][j] = sum[i][k] + sum[k+1][j];
                min_dp[i][j] = min(min_dp[i][j], min_dp[i][k]+min_dp[k+1][j] + sum[i][j]);   //更新最小得分
                max_dp[i][j] = max(max_dp[i][j], max_dp[i][k]+max_dp[k+1][j] + sum[i][j]);   //更新最大得分
            }
            if(len == n-1){
                min_sc = min(min_sc, min_dp[i][j]);   //沉淀出 i~j 的最小值
                max_sc = max(max_sc, max_dp[i][j]);   //沉淀出 i~j 的最大值
            }
        }
    }

    cout &lt;&lt; min_sc &lt;&lt; endl;
    cout &lt;&lt; max_sc &lt;&lt; endl;

    return  0;
}
</code></pre>
<h3 id="3-类似问题"><a href="#3-类似问题" class="headerlink" title="3.类似问题"></a>3.类似问题</h3><p>区间动归: <a href="https://blog.csdn.net/A_Comme_Amour/article/details/78477488" target="_blank" rel="noopener">邮局问题</a><br>树形区间动归: <a href="https://blog.csdn.net/qq_41205417/article/details/95939090" target="_blank" rel="noopener">加分二叉树</a></p>
<h4 id="乘积最大"><a href="#乘积最大" class="headerlink" title="乘积最大"></a>乘积最大</h4><p>设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积最大.<br>同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：<br>有一个数字串：312， 当N=3，K=1时会有以下两种分法：<br>1）3<em>12=36<br>2）31</em>2=62<br>这时，符合题目要求的结果是：31*2=62</p>
<ul>
<li><p>区间 DP</p>
<pre><code class="lang-cpp">int dp[50][50], num[50][50], a[50];
//num[i][j]表示 i~j 对应的数值, dp[i][k]表示 k 个乘号, 到 i 为止的最大乘积
</code></pre>
<p>关键: 初始化, <code>num[i][i]</code> 就是原来的数字, <code>dp[i][0] = num[1][i]</code> 乘号个数为 0 时, 到 i 位置的最大乘积就是 1~i 表示的数字本身. <code>dp[i][k] = max(dp[i][k], dp[j][k-1]*num[j+1][i])</code>  乘号之前 $\times$ 乘号之后</p>
<pre><code class="lang-cpp">int main(){
  int n, m, k, maxn=-1; cin &gt;&gt; n &gt;&gt; m;
  string str; cin &gt;&gt; str;
  for (int i = 1; i &lt;= n; i++){
      a[i] = str[i-1]-&#39;0&#39;;
      num[i][i] = a[i];
  }

  for (int i = 1; i &lt; n; ++i)
      for (int j = i+1; j &lt;= n; ++j)
          num[i][j] = num[i][j-1]*10 + a[j];

  fill(dp[0], dp[0]+50*50, 0);
  for (int i = 1; i &lt;= n; ++i)
      dp[i][0] = num[1][i];   //没有乘号的时候, 用于下面 dp[i][k-1] 初始化

  for (int k = 1; k &lt;= m; ++k) {            //乘号个数k
      for (int i = 1; i &lt;= n; ++i) {        //终点位置, 到 i 为止的最大乘积
          for (int j = 1; j &lt; i; ++j) {     //乘号位置j, j 之前的最大乘积dp[j][k-1], j 以后的数字 num[j+1][i]
              dp[i][k] = max(dp[i][k], dp[j][k-1]*num[j+1][i]);  //乘号之前 x 乘号之后
          }
      }
  }

  cout &lt;&lt; dp[n][m];
  return  0;
}
</code></pre>
</li>
</ul>
<hr>
<p><span id="NK-ctgc"></span></p>
<h2 id="NK-畅通工程-并查集-最小生成树-Kruscal-算法"><a href="#NK-畅通工程-并查集-最小生成树-Kruscal-算法" class="headerlink" title="NK-畅通工程 (并查集, 最小生成树 Kruscal 算法)"></a>NK-畅通工程 (并查集, 最小生成树 Kruscal 算法)</h2><h3 id="1-题目大意-28"><a href="#1-题目大意-28" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>给定村庄两两之间的距离, 输出所有村庄连通的最小长度.</p>
<p>每个测试用例的第1行给出评估的道路条数 N、村庄数目M (N, M &lt; =100 )；随后的 N 行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）. 为简单起见，村庄从1到M编号. 当N为0时，全部输入结束.</p>
<p>样例:</p>
<pre><code>3 3
1 2 1
1 3 2
2 3 4
1 3
2 3 2
0 100
------
3
?
</code></pre><h3 id="2-分析-13"><a href="#2-分析-13" class="headerlink" title="2.分析"></a>2.分析</h3><p>此题不建议用简单的 dfs 来做, 会很麻烦. 因为每次 dfs 都要重新设置 visit 数组, 要把每一个村庄依次作为 dfs 的起点, 比较最小的长度, 效率很低. 使用 g[a][b]+邻接表+visit 数组的老三样搭配, 不灵了, 而且数组越界.</p>
<p>此题我们使用一个经典简单的算法—<code>并查集</code>, 核心思想就是使用一个 Father 数组, <code>Father[i] = x</code> 表示 i 的父亲是 x, <code>Father[i] = x</code> 表示 i 是根节点. </p>
<p>并查集和最小路径问题是天然搭配, 只需每次 Union 操作, 就能表示加入了一条新的边. 必须要保证没有在同一颗树种, 不是同一个 root, 才能进行 Union, 可以保证访问过的不会再访问.</p>
<p>一次循环遍历所有边, 如果刚好所有点都 Union 到了同一棵树中, 表示图是连通的. 如果还有别的树单独在外, 表示非连通.</p>
<p>因为给定所有边的信息, 此题的最小生成树问题采用 Kruscal 算法, 直接按边排序, 每次直接找最短的边.</p>
<h3 id="3-个人代码-12"><a href="#3-个人代码-12" class="headerlink" title="3.个人代码"></a>3.个人代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define N 101
using namespace std;
int Father[N];

struct Path{
    int city1;
    int city2;
    int cost;
}buf[N];

bool cmp(Path p1,Path p2) { return p1.cost&lt;p2.cost;

int findRoot(int x){
    if(Father[x]==-1)return x;
    else {
        int tmp;
        tmp = findRoot(Father[x]);
        Father[x] = tmp;
        return tmp;
    }
}
int main()
{
    int n,m;
    int a,b;
    while(scanf(&quot;%d&quot;,&amp;n)!=EOF){
        if(n==0)break;
        for(int i=0;i&lt;N;i++){
            Father[i]=-1;   //全部初始化为 -1. 看做都是孤立的集合
        }
        scanf(&quot;%d&quot;,&amp;m);
        for(int i=0;i&lt;n;i++){
            scanf(&quot;%d%d%d&quot;,&amp;buf[i].city1,&amp;buf[i].city2,&amp;buf[i].cost);
        }
        sort(buf,buf+n,cmp);  //从最短的路开始找
        int TotalCost = 0;
        for(int i=0;i&lt;n;i++){
            int rootA = findRoot(buf[i].city1);
            int rootB = findRoot(buf[i].city2);
            if(rootA!=rootB){//若目前不在一个集合内(不是同一个父亲) 可以保证访问过的不会再访问)
                Father[rootA] = rootB;//把集合A放入B中 Union 操作
                TotalCost+=buf[i].cost;
            }
        }

        int cnt=0;
        for(int i=1;i&lt;=m;i++){
            if(Father[i]==-1){   //统计根节点的数量
                cnt++;
            }
        }
        if(cnt&lt;=1)
            printf(&quot;%d\n&quot;,TotalCost);
        else//无法构成最小生成树
            printf(&quot;?\n&quot;);
    }
    return 0;
}
</code></pre>
<h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><p>本题的并查集方法, 也可以用来统计连通分量的个数, 只需最后 <code>if(tree[i]==-1) ans++;</code> 计算树的个数即可.</p>
<hr>
<p><span id="NK-jzzh"></span></p>
<h2 id="NK-进制转换-10进制-VS-2进制"><a href="#NK-进制转换-10进制-VS-2进制" class="headerlink" title="NK-进制转换 10进制 VS 2进制"></a>NK-进制转换 10进制 VS 2进制</h2><p>(任意长度字符串进制转换: 可取用函数)</p>
<h3 id="1-题目大意-29"><a href="#1-题目大意-29" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数.<br>例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数.</p>
<h3 id="2-个人代码-5"><a href="#2-个人代码-5" class="headerlink" title="2.个人代码"></a>2.个人代码</h3><p>真正无惧溢出的进制转换. 在字符串上直接进行除法, 无需 int 存储.<br>无惧数组越界, 不需要设定字符数组长度.</p>
<pre><code class="lang-cpp">string conversion(int m, string a, int n){  //数字字符串 a 从 m 进制转换为 n 进制
    int len = a.length(), last_rem = 0;
    string res;
    for (int i = 0; i &lt; len;) {           //本循环功能: 做字符串除法, 每次除以 n
        last_rem = 0;   //开始了新一轮计算, 余数只是为了添加到结果中, 每次一定要重新置 0
        for (int j = i; j &lt; len; ++j) {   //每次从 不为 0 的最高位开始往后
            int cur_rem = (a[j] - &#39;0&#39; + last_rem * m) % n; //求余数, 供下一次使用
            a[j] = (a[j] - &#39;0&#39; + last_rem * m) / n + &#39;0&#39;;  //替换掉 a[j]
            last_rem = cur_rem;
        }
        res = char(last_rem + &#39;0&#39;) + res;
        while (a[i] == &#39;0&#39;) i++;   //跳过高位的 0, 即 086 -&gt; 86 直接计算
    }
    return res;
}
</code></pre>
<hr>
<p><span id="dp-set"></span></p>
<h2 id="动态规划常见问题合集"><a href="#动态规划常见问题合集" class="headerlink" title="动态规划常见问题合集"></a>动态规划常见问题合集</h2><pre><code class="lang-c++">(1)最长递增子序列
原理：
f[1]=1
f[i]=max(1,f[j]+1)(j&lt;i,v[j]&lt;v[i])
f[i]表示递增子序列以v[i]结束时它的最长长度

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

int main() {
    vector&lt;int&gt;v{ 0,2,3,4,4,3,2,5,34,4,6,123 };
    vector&lt;int&gt;num;
    num.resize(v.size());
    num[0] = 1;
    for (int i = 2; i &lt; v.size(); i++) {
        vector&lt;int&gt;n;
        n.push_back(1);
        for (int j = 0; j &lt; i; j++)
            if (v[j] &lt;= v[i])
                n.push_back(num[j] + 1);
        num[i] = *max_element(n.begin(), n.end());
    }
    cout &lt;&lt; *max_element(num.begin(), num.end())&lt;&lt;endl;
    return 0;
}


(2)最长公共子序列
原理：
dp[i][j]表示s1前i个字符和s2前j个字符组成的两个前缀字符串的最长公共子串长度

dp[0][i]=0(0=&lt;i&lt;=m)
dp[j][0]=0(0=&lt;j&lt;=n)
dp[i][j]=dp[i-1][j-1]+1 (s[i]==s[j])
dp[i][j]=max{dp[i-1][j],dp[i][j-1]} (s[i]!=s[j])    

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

int main() {
    string s1 = &quot;asdfuuu&quot;;
    string s2 = &quot;dfummm&quot;;
    vector&lt;vector&lt;int&gt;&gt;dp;
    int m = s1.length();
    int n = s2.length();
    dp.resize(m + 1);
    for (int i = 0; i &lt;= m; i++)
        dp[i].resize(n + 1);
    for (int i = 0; i &lt;= m; i++)
        dp[i][0] = 0;
    for (int j = 0; j &lt;= n; j++)
        dp[0][j] = 0;
    for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt;= n; j++)
            if (s1[i] == s2[j])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
    cout &lt;&lt; dp[m][n] &lt;&lt; endl;
    return 0;
}

(3)最长连续公共子序列
原理：
dp[i][j]表示以s1[i]，s2[j]为结尾的字符串的公共长度

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

int main() {
    string s1 = &quot;asdfuuuu&quot;;
    string s2 = &quot;dfuummm&quot;;
    vector&lt;vector&lt;int&gt;&gt;dp;
    int m = s1.length();
    int n = s2.length();
    dp.resize(m + 1);
    for (int i = 0; i &lt;= m; i++)
        dp[i].resize(n + 1);
    for (int i = 0; i &lt;= m; i++)
        dp[i][0] = 0;
    for (int j = 0; j &lt;= n; j++)
        dp[0][j] = 0;
    for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt;= n; j++)
            if (s1[i-1] == s2[j-1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
    int max = -1;
    for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt;= n; j++)
            if (dp[i][j] &gt; max)
                max = dp[i][j];
    cout &lt;&lt; max &lt;&lt; endl;
    return 0;
}


(4)最大连续子序列的和
原理：
dp[i]表示以第i个数字为结尾的连续子序列的和dp[i]=max{dp[i-1]+a[i],a[i]}
示例程序:

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main() {
    vector&lt;int&gt;v{ 1,2,3,-5,3,5,2,-7 };
    vector&lt;int&gt;sum;
    sum.resize(8);
    sum[0] = v[0];
    for (int i = 1; i &lt; v.size(); i++)
        sum[i] = max(sum[i - 1] + v[i], v[i]);
    cout &lt;&lt; *max_element(sum.begin(), sum.end());
    return 0;
}


(5)最大子序列和
int findMaxSum(vector&lt;int&gt;v){
    int sum=0;
    int maxSum=0;
    for(int i=0;i&lt;v.size();i++){
        sum+=v[i];
        if(sum&gt;maxSum)
            maxSum=sum;
        else if(sum&lt;0)
            sum=0;
    }
    cout&lt;&lt;maxSum&lt;&lt;endl;
}


(7)最大子序列和，但是有一个限定最大值，就转换为动态规划问题中的背包问题
对于每个变量来说，它的value同时也是它的cost
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - intValue[i]] + intValue[i]);
当遇到背包中的值为double类型的时候，可以将其乘以10的次方，转换为整数


(6)0-1背包问题要注意vector&lt;vector&lt;int&gt;&gt;dp的时候不一定是0！！！，必须要初始化
原理：
dp[i][j]表示总体积不超过j的条件下，前i件物品可以达到的最大价值

点菜问题：
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

class Node {
public:
    int value;
    int cost;
};


int main() {
    vector&lt;Node&gt;v;
    vector&lt;vector&lt;int&gt;&gt;dp;
    int n;
    int cost;
    while (cin &gt;&gt;cost&gt;&gt; n) {
        v.clear();
        dp.clear();
        v.resize(0);
        dp.resize(0);
        v.resize(n + 1);
        for (int i = 1; i &lt;= n; i++)
            cin &gt;&gt; v[i].cost &gt;&gt; v[i].value;
        dp.resize(n + 1);
        for (int i = 0; i &lt;= n; i++)
            dp[i].resize(cost+1);
        //这里当时调试了几次，由于将cost写为n的原因，初始化过程必不可少
        for (int i = 0; i &lt;= cost; i++)dp[0][i] = 0;
        for (int i = 1; i &lt;= n; i++) {
            for (int j = cost; j &gt;= v[i].cost; j--)
                //dp[i][j]表示在总体积不超过j的情况下，前i个物体可以达到的最大价值
                dp[i][j] = max(dp[i - 1][j - v[i].cost] + v[i].value, dp[i - 1][j]);
            for (int j = v[i].cost - 1; j &gt;= 0; j--)
                dp[i][j] = dp[i - 1][j];
        }
        cout &lt;&lt; dp[n][cost] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<hr>
<p><span id="NK-dcth"></span></p>
<h2 id="NK-单词替换"><a href="#NK-单词替换" class="headerlink" title="NK-单词替换"></a>NK-单词替换</h2><ol>
<li><p>题目大意</p>
<pre><code>You want someone to help you
You
I
</code></pre><pre><code>I want someone to help you
</code></pre></li>
<li><p>核心代码<br>手写 split 函数, 省去字符串匹配的麻烦</p>
<pre><code class="lang-C++">void split(string s) {
 v.clear();
 v.resize(0);
 int index = s.find(&#39; &#39;);
 while(index!=-1){
     v.push_back(s.substr(0, index));
     s = s.substr(index+1, s.length() - index - 1);
     index = s.find(&#39; &#39;);
 }
 v.push_back(s);
}
</code></pre>
</li>
</ol>
<hr>
<p><span id="NK-graph"></span></p>
<h2 id="图相关算法"><a href="#图相关算法" class="headerlink" title="图相关算法"></a>图相关算法</h2><pre><code class="lang-c++">（1）计算联通子图的数目

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
/*
    给出城镇标号，表示这两个城镇是联通的
    求出需要再建多少条路才能使得所有城镇联通
*/

vector&lt;int&gt;tree;    //用来包含每个结点的父结点
int findRoot(int x) {   //寻找根节点
    if (tree[x] == -1)
        return x;
    else {
        int tmp = findRoot(tree[x]);
        tree[x] = tmp;
        return tmp;
    }
}


int main() {
    int n, e;
    while (cin &gt;&gt; n &gt;&gt; e) {
        tree.clear();
        tree.resize(n + 1);
        for (int i = 1; i &lt;= n; i++)
            tree[i] = -1;
        int a, b;
        for (int i = 1; i &lt;= e; i++) {
            cin &gt;&gt; a &gt;&gt; b;
            a = findRoot(a);
            b = findRoot(b);
            if (a != b)
                tree[a] = b;
        }
        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
            if (tree[i] == -1)
                ans++;
        cout &lt;&lt; ans - 1 &lt;&lt; endl;
    }
    return 0;
}


（2）求出具有最多元素的联通子图的结点数量

//思路：添加一个sum数组，sum[i]表示以第i个结点为根结点的树的结点数目


#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

vector&lt;int&gt;tree;    //用来包含每个结点的父结点
vector&lt;int&gt;sum;     //用来表示以sum[i]为根节点的树中结点数目

int findRoot(int x) {   //寻找根节点
    if (tree[x] == -1)
        return x;
    else {
        int tmp = findRoot(tree[x]);
        tree[x] = tmp;
        return tmp;
    }
}

int main() {
    int n;
    while (cin &gt;&gt; n ) {
        tree.clear();
        tree.resize(101);
        sum.clear();
        sum.resize(101);
        for (int i = 1; i &lt;= 100; i++) {
            tree[i] = -1;
            sum[i] = 1;
        }
        int a, b;
        for (int i = 1; i &lt;= n; i++) {
            cin &gt;&gt; a &gt;&gt; b;
            a = findRoot(a);
            b = findRoot(b);
            if (a != b) {
                tree[a] = b;
                sum[b] += sum[a];
            }
        }
        int max = 0;
        for (int i = 1; i &lt;= 100; i++)
            if (sum[i] &gt; max)
                max = sum[i];
        cout &lt;&lt; max &lt;&lt; endl;
    }
    return 0;
}


（3）Kruskal算法，最小生成树
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

/*
    题目：输入结点和边的长度，输出最小生成树的长度
    注意：要判断是否能够构成一个联通图
*/

vector&lt;int&gt;tree;    //用来包含每个结点的父结点
int findRoot(int x) {   //寻找根节点
    if (tree[x] == -1)
        return x;
    else {
        int tmp = findRoot(tree[x]);
        tree[x] = tmp;
        return tmp;
    }
}

class Edge {
public:
    int a, b;
    int length;
    bool operator&lt;(Edge&amp; e) {
        return length &lt; e.length;
    }
};

int main() {
    int n;
    while (cin &gt;&gt; n) {
        if (n == 0)
            break;
        tree.resize(n + 1);
        vector&lt;Edge&gt;e;
        e.resize(n*(n - 1) / 2);
        for (int i = 1; i &lt;= n; i++)
            tree[i] = -1;
        for (int i = 0; i &lt; e.size(); i++)
            cin &gt;&gt; e[i].a &gt;&gt; e[i].b &gt;&gt; e[i].length;
        sort(e.begin(), e.end());
        int ans = 0;
        for (int i = 0; i &lt; e.size(); i++) {
            int a = findRoot(e[i].a);
            int b = findRoot(e[i].b);
            if (a != b) {
                tree[a] = b;
                ans += e[i].length;
            }
        }
        int num = 0;    //判断根节点的数目，如果不为1说明这个图是不连通的
        for (int i = 1; i &lt; tree.size(); i++)
            if (tree[i] == -1)
                num++;
        if (num != 1)
            cout &lt;&lt; &quot;图是不连通的&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}


（4）判断一个图是否存在环
/*
    原理：一个拓扑排序，统计每个结点的入度，每次找出来一个入度为0的结点，然后它的所有子结点
        的入度减1，然后加一个标志位，防止被访问过的结点重复被提取出来
*/

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;

class Node {
public:
    int degree;
    bool taken;
    vector&lt;int&gt;next;
    Node() {
        taken = false;
        degree = 0;
    }
};

int main() {
    int n, m;
    while (cin &gt;&gt; n &gt;&gt; m) {
        vector&lt;Node&gt;v;
        v.resize(n);
        int s, e;
        for (int i = 1; i &lt;= m; i++) {
            cin &gt;&gt; s &gt;&gt; e;
            v[s].next.push_back(e);
            v[e].degree++;
        }
        queue&lt;int&gt;q;
        int ans = 0;
        for (int i = 0; i &lt; n; i++)
            if (v[i].degree == 0)
                q.push(i);
        while (!q.empty()) {
            int index = q.front();
            v[index].taken = true;
            q.pop();
            ans++;
            for (int i : v[index].next)
                v[i].degree--;
            for (int i = 0; i &lt; n; i++)
                if (v[i].degree == 0 &amp;&amp; v[i].taken == false)
                    q.push(i);
        }
        if (ans != n)
            cout &lt;&lt; &quot;图存在环&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;图不存在环&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<hr>
<p><span id="NK-dzs"></span></p>
<h2 id="C-大整数-乘法"><a href="#C-大整数-乘法" class="headerlink" title="C++大整数 - 乘法"></a>C++大整数 - 乘法</h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>输入一个正整数N，输出N的阶乘。<br>输入描述:<br>正整数N(0&lt;=N&lt;=1000)<br>输出描述:<br>输入可能包括多组数据，对于每一组输入数据，输出N的阶乘</p>
<h3 id="2-题解代码"><a href="#2-题解代码" class="headerlink" title="2.题解代码"></a>2.题解代码</h3><pre><code class="lang-c++">using namespace std;

class BigInteger {
public:
    vector&lt;int&gt;v;
    void set(int x) {
        v.clear();
        v.resize(0);
        do {
            v.push_back(x%10000);
            x /= 10000;
        } while (x != 0);
    }

    void output() {
        for (int i = v.size() - 1; i &gt;= 0; i--) {
            if (i != v.size() - 1)
                cout &lt;&lt; setw(4) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; v[i];
            else
                cout &lt;&lt; v[i];
        }
        cout &lt;&lt; endl;
    }

    BigInteger operator*(int x) const{
        int jin = 0;
        BigInteger res;
        for (int i = 0; i &lt; v.size(); i++) {
            res.v.push_back((x*v[i] + jin) % 10000);
            jin = (x*v[i] + jin) / 10000;
        }
        if (jin &gt; 0)
            res.v.push_back(jin);
        return res;
    }
};

int main() {
    int N;
    while (cin &gt;&gt; N) {
        BigInteger a;
        a.set(1);
        for (int i = 1; i &lt;= N; i++)
            a =a* i;
        a.output();
    }
    return 0;

}
</code></pre>
<h2 id="C-大整数-大整数的因子"><a href="#C-大整数-大整数的因子" class="headerlink" title="C++大整数 - 大整数的因子"></a>C++大整数 - 大整数的因子</h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>已知正整数k满足2&lt;=k&lt;=9，现给出长度最大为30位的十进制非负整数c，求所有能整除c的k.</p>
<h3 id="2-题解代码-1"><a href="#2-题解代码-1" class="headerlink" title="2.题解代码"></a>2.题解代码</h3><pre><code class="lang-c++">while (cin &gt;&gt; s) {
    if (s == &quot;-1&quot;)continue;
    vector&lt;int&gt;v;
    int flag;
    for (int k = 2; k &lt;= 9; k++) {   //对每个因子整除
        flag = 0;
        for (int i = 0; i &lt; s.length(); i++) {   //模拟大整数的除法, 从高位开始
            flag *= 10;
            if (flag + (s[i] - &#39;0&#39;) &lt; k)
                flag += (s[i] - &#39;0&#39;);
            else
                flag = (flag + (s[i] - &#39;0&#39;)) % k;
        }
        if (flag == 0)v.push_back(k);   //flag 为 0 才表示除尽
    }
}
</code></pre>
<hr>
<p><span id="NK-sxzs"></span></p>
<h2 id="扇形着色问题"><a href="#扇形着色问题" class="headerlink" title="扇形着色问题"></a>扇形着色问题</h2><p>将一个圆形分成n个扇形，现有m种涂料，现在用这m种涂料对扇形进行着色，要求相邻两个扇形的颜色不能相同</p>
<p>思路：<br>    第一个m种可能，第二个m-1种可能，第n个m-1种可能，所以一共就是 <code>m(m-1)^(n-1)</code>，但是由于第n个可能跟第一个进行重合，所以就需要减去这种情况，可以视作是第n个与第一个构成一个扇区进行着色，所以就是 <code>A(n-1,m)</code><br>    所以 <code>A(n,m)=m*(m-1)^(n-1)+A(n-1,m)</code></p>
<p>编程：</p>
<pre><code class="lang-cpp">    int count(n,m){
        if(n==0||m==0)
            return 0;
        if(n==1)
            return m;
        vector&lt;int&gt;v;
        v.resize(n+1);
        v[1]=m;
        v[2]=m*(m-1);
        for(int i=3;i&lt;=n;i++)
            v[i]=int(m*pow(m-1,i-1)-v[i-1]);
        cout&lt;&lt;v[n]&lt;&lt;endl;
    }
</code></pre>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hopenx.github.io" rel="external nofollow noreferrer">HopenX</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hopenx.github.io/2020/02/06/pat-advance/">https://hopenx.github.io/2020/02/06/pat-advance/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://hopenx.github.io" target="_blank">HopenX</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/PAT/">
                                    <span class="chip bg-color">PAT</span>
                                </a>
                            
                                <a href="/tags/OJ/">
                                    <span class="chip bg-color">OJ</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/02/06/ml-study-notes/">
                    <div class="card-image">
                        
                        
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/featureimages/11.jpg" class="responsive-img" alt="机器学习基础(一) 概述">
                        
                        <span class="card-title">机器学习基础(一) 概述</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            机器学习概述，常见的机器学习算法概览，包括监督学习和非监督学习，损失函数，优化方法，评价指标，参数调优的基本概念
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-02-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    机器学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">机器学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/02/02/hello-world/">
                    <div class="card-image">
                        
                        
                        <img src="https://i.loli.net/2020/02/09/2OERK3tFJve4YDH.gif" data-original="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/medias/featureimages/21.jpg" class="responsive-img" alt="欢迎来到 Hexo">
                        
                        <span class="card-title">欢迎来到 Hexo</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本博客采用 Hexo 快速搭建，也欢迎大家上手使用 Hexo，选择自己喜欢的主题，省时省力，工具齐全，生态优越，可扩展性好
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-02-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            HopenX
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://hopenx.github.io" target="_blank">HopenX</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">80.5k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "1";
                    var startDate = "2";
                    var startHour = "0";
                    var startMinute = "";
                    var startSecond = "";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 ";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/hopenx" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1152214965" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1152214965" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>

<script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="https://cdn.jsdelivr.net/gh/hopenx/hopenx.github.io@master/libs/instantpage/instantpage.js" type="module"></script>
    

<script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>
