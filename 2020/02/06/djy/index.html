<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>djy | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="PAT-甲级 做题笔记目录0000 做题 Tips 基本经验1003 Emergency (Dijkstra 算法)1004 Counting Leaves (计算叶节点数，DFS&#x2F;BFS 树算法)1007 Maximum Subsequence Sum(最大子序列和)1010 Radix (进制转换&#x2F;二分法)1012 The Best Rank (应用问题，数据结构设计，多维度排序)1013 B">
<meta property="og:type" content="article">
<meta property="og:title" content="djy">
<meta property="og:url" content="http://yoursite.com/2020/02/06/djy/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="PAT-甲级 做题笔记目录0000 做题 Tips 基本经验1003 Emergency (Dijkstra 算法)1004 Counting Leaves (计算叶节点数，DFS&#x2F;BFS 树算法)1007 Maximum Subsequence Sum(最大子序列和)1010 Radix (进制转换&#x2F;二分法)1012 The Best Rank (应用问题，数据结构设计，多维度排序)1013 B">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-05T17:15:03.000Z">
<meta property="article:modified_time" content="2020-02-05T17:16:50.110Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-djy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/06/djy/" class="article-date">
  <time datetime="2020-02-05T17:15:03.000Z" itemprop="datePublished">2020-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      djy
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PAT-甲级-做题笔记"><a href="#PAT-甲级-做题笔记" class="headerlink" title="PAT-甲级 做题笔记"></a>PAT-甲级 做题笔记</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>0000 <a href="#0000">做题 Tips 基本经验</a><br>1003 <a href="#1003">Emergency (Dijkstra 算法)</a><br>1004 <a href="#1004">Counting Leaves (计算叶节点数，DFS/BFS 树算法)</a><br>1007 <a href="#1007">Maximum Subsequence Sum(最大子序列和)</a><br>1010 <a href="#1010">Radix (进制转换/二分法)</a><br>1012 <a href="#1012">The Best Rank (应用问题，数据结构设计，多维度排序)</a><br>1013 <a href="#1013">Battle Over Cities (图的遍历，统计强连通分量的个数，DFS)</a><br>1014 <a href="#1014">Waiting in Line (队列应用，排队问题)</a><br>1015 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805495863296000" target="_blank" rel="noopener">Reversible Primes (进制转换+判断素数：可取用函数)</a><br>1016 <a href="#1016">Phone Bills (日期类计算)</a><br>1018 <a href="#1018">Public Bike Management (图最短路径 Dijkstra + DFS)</a><br>1020 <a href="#1020">Tree Traversals (已知后序和中序，转前序/层序)</a><br>1021 <a href="#1021">Deepest Root (求树中最长的路径，DFS，连通分量)</a></p>
<hr>
<h2 id="0000-做题-Tips-基本经验"><a href="#0000-做题-Tips-基本经验" class="headerlink" title="0000 做题 Tips 基本经验"></a>0000 做题 Tips 基本经验<span id="0000"></span></h2><ol>
<li><p>最后千万别栽在头文件上，比如 reverse() 属于 &lt; algorithm&gt;</p>
</li>
<li><p>输出多行的时候，最后有一个多余的空行也没问题<br>比如使用 <code>cout &lt;&lt; a &lt;&lt; endl</code> 三次，样例输出：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p> 实际输出：最后有一个多余空行没关系</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="1003-Emergency-Dijkstra-算法"><a href="#1003-Emergency-Dijkstra-算法" class="headerlink" title="1003 Emergency (Dijkstra 算法)"></a>1003 Emergency (Dijkstra 算法)<span id="1003"></span></h2><h3 id="1-题目大意"><a href="#1-题目大意" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>n个城市m条路，每个城市有救援小组，所有的边的边权已知。给定起点和终点，求从起点到终点的最短路径条数以及最短路径上的救援小组数目之和。如果有多条就输出点权（城市救援小组数目）最大的那个</p>
<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>用一遍Dijkstra算法～救援小组个数相当于点权，用Dijkstra求边权最小的最短路径的条数，以及这些最短路径中点权最大的值～dis[i]表示从出发点到i结点最短路径的路径长度，num[i]表示从出发点到i结点最短路径的条数，w[i]表示从出发点到i点救援队的数目之和～当判定dis[u] + e[u][v] &lt; dis[v]的时候，不仅仅要更新dis[v]，还要更新num[v] = num[u], w[v] = weight[v] + w[u]; 如果dis[u] + e[u][v] == dis[v]，还要更新num[v] += num[u]，而且判断一下是否权重w[v]更小，如果更小了就更新w[v] = weight[v] + w[u]</p>
<h3 id="3-个人代码"><a href="#3-个人代码" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">PTA-1003</a></p>
<h3 id="4-学习要点"><a href="#4-学习要点" class="headerlink" title="4. 学习要点"></a>4. 学习要点</h3><blockquote>
<p>1.真正理解单源最短路径，每一次选择的 dis 都是相对于源点的最短路径<br>2.大数组要设为全局变量<br>3.外层循环 i：n 次循环，每次访问一个新点，保证 n 个点全访问到；内层循环 j：继续寻找还未访问的点，找 dis 最小的访问；内层循环 k：更新所有能够更新的 dis</p>
</blockquote>
<hr>
<h2 id="1004-Counting-Leaves-dfs-bfs-树算法"><a href="#1004-Counting-Leaves-dfs-bfs-树算法" class="headerlink" title="1004 Counting Leaves (dfs/bfs 树算法)"></a>1004 Counting Leaves (dfs/bfs 树算法)<span id="1004"></span></h2><h3 id="1-题目大意-1"><a href="#1-题目大意-1" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出一棵树，问每一层各有多少个叶子结点</p>
<h3 id="2-坑"><a href="#2-坑" class="headerlink" title="2. 坑"></a>2. 坑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[tmp].lev &#x3D; list[fa].lev + 1;  &#x2F;&#x2F;出问题,不一定按照顺序输入</span><br></pre></td></tr></table></figure>
<p>有可能先 03 后 01，fa 的 lev 还没确定，不能给孩子节点 +1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">03 1 02</span><br><span class="line">01 1 03</span><br></pre></td></tr></table></figure>

<h3 id="3-个人代码-1"><a href="#3-个人代码-1" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184" target="_blank" rel="noopener">PTA-1004</a></p>
<h3 id="4-正确方法"><a href="#4-正确方法" class="headerlink" title="4. 正确方法"></a>4. 正确方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : <span class="built_in">list</span>[fa].v) &#123;</span><br><span class="line">        <span class="built_in">list</span>[ch].lev = <span class="built_in">list</span>[fa].lev + <span class="number">1</span>;</span><br><span class="line">        dfs(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);   <span class="comment">//通过 DFS 一层层给叶子节点 lev+1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1007-Maximum-Subsequence-Sum-最大子序列和"><a href="#1007-Maximum-Subsequence-Sum-最大子序列和" class="headerlink" title="1007 Maximum Subsequence Sum (最大子序列和)"></a>1007 Maximum Subsequence Sum (最大子序列和)<span id="1007"></span></h2><h3 id="1-题目大意-2"><a href="#1-题目大意-2" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>求最大连续子序列和，输出最大的和以及这个子序列的开始值和结束值。如果所有数都小于0，那么认为最大的和为0，并且输出首尾元素</p>
<h3 id="2-分析-1"><a href="#2-分析-1" class="headerlink" title="2.分析"></a>2.分析</h3><p>本质上是<strong>动态规划</strong>的思想，数组为<code>vec[]</code>，设<code>dp[i]</code> 是以<code>vec[i]</code>结尾的子数组的最大和，对于元素<code>vec[i+1]</code>, 它有两种选择：<code>vec[i+1]</code>接着前面的子数组构成最大和; <code>vec[i+1]</code>自己单独构成子数组。则<code>dp[i+1] = max{dp[i]+vec[i+1],  vec[i+1]}</code></p>
<p>简化则用一个 temp_sum 和一个 temp_first 解决，真正最大和为 sum，起始点为 first 和 last，建立局部和全局的关系。如果 <code>temp_sum &lt; 0</code>, 说明目前这一段对后续的序列和已经没有加成作用，可以舍弃另立门户，令<code>temp_sum = 0</code></p>
<h3 id="3-个人代码-2"><a href="#3-个人代码-2" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始值设置容易坑：sum要为-1 才能开始</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">-1</span>, temp_sum=<span class="number">0</span>, first=<span class="number">0</span>, last=k<span class="number">-1</span>, temp_first=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">    temp_sum += a[j];</span><br><span class="line">    <span class="keyword">if</span>(temp_sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        temp_sum = <span class="number">0</span>;</span><br><span class="line">        temp_first = j+<span class="number">1</span>;   <span class="comment">//本段已经可以舍弃，开始新一段</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(temp_sum &gt; sum)&#123;</span><br><span class="line">        sum = temp_sum;</span><br><span class="line">        first = temp_first;</span><br><span class="line">        last = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;  <span class="comment">//如果全负则为 0，根据题目要求不要漏情况</span></span><br></pre></td></tr></table></figure>

<h3 id="4-类似题"><a href="#4-类似题" class="headerlink" title="4. 类似题"></a>4. 类似题</h3><p><a href="https://www.cnblogs.com/grandyang/p/4480780.html" target="_blank" rel="noopener">最长无重复子串</a></p>
<hr>
<h2 id="1010-Radix-进制转换-二分法"><a href="#1010-Radix-进制转换-二分法" class="headerlink" title="1010 Radix (进制转换/二分法)"></a>1010 Radix (进制转换/二分法)<span id="1010"></span></h2><p>###1. 题目大意<br>给定两个相等数，已知一个数的进制，求另外一个数的进制（radix-&gt;基数）</p>
<p>###2. 分析<br>通用函数<code>cal(string str, int radix)</code>把任意进制的数转换为 10 进制数<br>在使用搜索遍历，找到另一个数对应的进制</p>
<p>###3.个人代码<br><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536" target="_blank" rel="noopener">PTA-1010</a></p>
<p>转换函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">long</span> <span class="keyword">long</span> radix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> target=<span class="number">0</span>, bak = <span class="number">1</span>;</span><br><span class="line">    reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">            target += (c - <span class="string">'0'</span>) * bak;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            target += (c - <span class="string">'a'</span> + <span class="number">10</span>) * bak;</span><br><span class="line">        bak *= radix;  <span class="comment">//也可以使用&lt;cmath&gt;的 pow()函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">find_radix</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">long</span> <span class="keyword">long</span> tar)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = *max_element(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());  <span class="comment">//最大字母</span></span><br><span class="line">    <span class="comment">//进制至少比最大字母要大</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> low = <span class="built_in">isdigit</span>(c) ? c-<span class="string">'0'</span> : c-<span class="string">'a'</span>+<span class="number">10</span>;</span><br><span class="line">    low += <span class="number">1</span>;  <span class="comment">//必须要加一,至少多1</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> high = <span class="built_in">max</span>(low, tar);  <span class="comment">//进制最大不会大于目标 tar</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = cal(str, mid);</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; <span class="number">0</span> || tmp &gt; tar) high = mid - <span class="number">1</span>;  <span class="comment">//小于 0 也是进制太大</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmp == tar) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-学习要点-1"><a href="#4-学习要点-1" class="headerlink" title="4. 学习要点"></a>4. 学习要点</h3><blockquote>
<ol>
<li>进制转换这种大数字的乘法很容易溢出，必须要用 <code>long long</code></li>
<li>暴力搜索（从 2 到 ∞ 容易超时）最好用二分法，并且限定范围：最小是 <code>low</code> 至少是最大的那个字母+1，比如 fff 最少是 15+1=16 进制，最大是<code>high</code>不超过目标 <code>tar</code></li>
<li>可以使用反向迭代器 <code>it = n.rbegin(); it != n.rend()</code>代替<code>reverse()</code></li>
</ol>
</blockquote>
<hr>
<h2 id="1012-The-Best-Rank-数据结构设计-多维度排序"><a href="#1012-The-Best-Rank-数据结构设计-多维度排序" class="headerlink" title="1012 The Best Rank (数据结构设计/多维度排序)"></a>1012 The Best Rank (数据结构设计/多维度排序)<span id="1012"></span></h2><h3 id="1-题目大意-3"><a href="#1-题目大意-3" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>找出每个人自己最优势的科目，也就是单独排名最好的科目，优先级 A &gt; C &gt; M &gt; E</p>
<ul>
<li>Sample Input:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">310101 98 85 88</span><br><span class="line">310102 70 95 88</span><br><span class="line">310103 82 87 94</span><br><span class="line">310104 91 91 91</span><br><span class="line">310105 85 90 90</span><br><span class="line">310101</span><br><span class="line">310102</span><br><span class="line">310103</span><br><span class="line">310104</span><br><span class="line">310105</span><br><span class="line">999999</span><br></pre></td></tr></table></figure></li>
<li>Sample Output:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 C</span><br><span class="line">1 M</span><br><span class="line">1 E</span><br><span class="line">1 A</span><br><span class="line">3 A</span><br><span class="line">N&#x2F;A</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-个人代码"><a href="#2-个人代码" class="headerlink" title="2. 个人代码"></a>2. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480" target="_blank" rel="noopener">PTA-1012</a></p>
<h3 id="3-学习要点"><a href="#3-学习要点" class="headerlink" title="3. 学习要点"></a>3. 学习要点</h3><p>数据结构设计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="comment">//一定要用数组形式，避免过多变量 int c, m, e, c_r, m_r, e_r, a_r;</span></span><br><span class="line">    <span class="keyword">int</span> id, best;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>], rank[<span class="number">4</span>];</span><br><span class="line">&#125;stu[<span class="number">2001</span>];  <span class="comment">//输入学生序列，非学号排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> exist[<span class="number">1000000</span>], flag=<span class="number">-1</span>; <span class="comment">//exist 至少 &gt;0, 顺便建立 id-输入序号 映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 flag 配置作用，避免写过多重复的 cmp 函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span></span>&#123; <span class="keyword">return</span> a.score[flag] &gt; b.score[flag];&#125;</span><br></pre></td></tr></table></figure>
<p>输入后，利用<code>exist[stu[k].id] = k + 1; k++</code> 依次建立映射<br>输出时，利用<code>cin &gt;&gt; tmp; ex = exist[tmp]</code>和<code>stu[ex-1]</code>实现映射，无需 find<br>处理时，使用<code>sort(stu, stu+n, cmp)</code> 循环 <code>flag++</code>，实现分学科多次排序，确定 <code>rank[]</code></p>
<hr>
<h2 id="1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）"><a href="#1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）" class="headerlink" title="1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）"></a>1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）<span id="1013"></span></h2><h3 id="1-题目大意-4"><a href="#1-题目大意-4" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出n个城市之间有相互连接的m条道路，当删除一个城市和其连接的道路的时候，问其他几个剩余的城市至少要添加多少个路线，才能让它们重新变为连通图</p>
<h3 id="2-分析-2"><a href="#2-分析-2" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>n 连通分量，最少需要 n-1 条边相连，所以本题实质就是求「去除某点及其相连的边」后，剩余的「连通分量个数」是一个图算法，需要用图的遍历来解决 (DFS)</p>
<blockquote>
<p>求连通分量依据：一次 <code>dfs()</code>走到底，可以访问完一个连通分量</p>
</blockquote>
<p>数据结构：</p>
<blockquote>
<p>涉及图的遍历，要考虑 <code>visit[]</code>数组<br>图的路径存储，使用二维矩阵</p>
</blockquote>
<h3 id="3-个人代码-3"><a href="#3-个人代码-3" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">PTA-1013</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur, cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cur;</span><br><span class="line">        <span class="built_in">fill</span>(visited, visited+n, <span class="literal">false</span>);</span><br><span class="line">        visited[cur] = <span class="literal">true</span>;  <span class="comment">//相当于把本点去除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;  <span class="comment">//依次计算所有连通分量，而非从本点出发</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">                dfs(j);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> st)</span></span>&#123;   <span class="comment">//只用来 visit，不负责计数</span></span><br><span class="line">    visited[st] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i] &amp;&amp; e[st][i])&#123;   <span class="comment">//未访问且有路</span></span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1014-Reversible-Primes（队列应用-排队问题）"><a href="#1014-Reversible-Primes（队列应用-排队问题）" class="headerlink" title="1014 Reversible Primes（队列应用 排队问题）"></a>1014 Reversible Primes（队列应用 排队问题）<span id="1014"></span></h2><h3 id="1-题目大意-5"><a href="#1-题目大意-5" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>n个窗口，每个窗口可以排队m人。有k位用户需要服务，给出了每位用户需要的minute数，所有客户在8点开始服务，如果有窗口还没排满就入队，否则就在黄线外等候。如果有某一列有一个用户走了服务完毕了，黄线外的人就进来一个。如果同时就选窗口数小的。求q个人的服务结束时间。<br>如果一个客户在17:00以及以后还没有开始服务（此处不是结束服务是开始17:00）就不再服务输出sorry；如果这个服务已经开始了，无论时间多长都要等他服务完毕。</p>
<h3 id="2-学习要点"><a href="#2-学习要点" class="headerlink" title="2. 学习要点"></a>2. 学习要点</h3><p>面对此类题目，总想按照 timeline 每分每秒去决策，其实队列的问题用队列解决。</p>
<p>以每个窗口为单位设计结构体，<code>poptime</code> 用于刚入黄线的人决策，<code>endtime</code> 用于已经在队内的人是否会 sorry 决策，<code>q</code> 表示本队列内排队情况。</p>
<p>给定客户序列，则以每一个客户为循环单位<code>(index++)</code>，队列有一个进就会有一个出，每次变动一个单位，更新各个队列的<code>poptime endtime q</code>等变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> poptime, endtime;  <span class="comment">//队首的人出队（结束）的时间, 队尾的人结束的时间</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//第 1 步：n*m 个客户先抢占黄线内, 直接瞬间涌入，不存在选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cap; ++i) &#123;    <span class="comment">//看做行和列，先抢第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt;= k)&#123;</span><br><span class="line">                win[j].q.push(time[index]);</span><br><span class="line">                <span class="keyword">if</span>(win[j].endtime &gt;= <span class="number">540</span>)</span><br><span class="line">                    sorry[index] = <span class="literal">true</span>;</span><br><span class="line">                win[j].endtime += time[index];</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>)  <span class="comment">//对于第一行，出队时间即本队结束时间，做一个初始化</span></span><br><span class="line">                    win[j].poptime = win[j].endtime;</span><br><span class="line">                res[index] = win[j].endtime;  <span class="comment">//刚进来的，自己是队尾，队伍结束就是自己结束</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第 2 步：后续的客户</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt;= k)&#123;   <span class="comment">//while一次循环表示一个客户的选择</span></span><br><span class="line">        <span class="keyword">int</span> temp_min = win[<span class="number">1</span>].poptime, temp_win = <span class="number">1</span>;  <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;   <span class="comment">//找最早出队的</span></span><br><span class="line">            <span class="keyword">if</span>(win[i].poptime &lt; temp_min)&#123;</span><br><span class="line">                temp_win = i;</span><br><span class="line">                temp_min = win[i].poptime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        win[temp_win].q.pop();</span><br><span class="line">        win[temp_win].q.push(time[index]);</span><br><span class="line">        win[temp_win].poptime += win[temp_win].q.front(); <span class="comment">//更新：最前面那个人完成的时间就是出队时间</span></span><br><span class="line">        <span class="keyword">if</span>(win[temp_win].endtime &gt;= <span class="number">540</span>)  <span class="comment">//endtime 还未更新，是看的前一个人的完成时间，是否超时</span></span><br><span class="line">            sorry[index] = <span class="literal">true</span>;</span><br><span class="line">        win[temp_win].endtime += time[index];  <span class="comment">//更新：刚进来的这个人的完成时间就是本队的完成时间</span></span><br><span class="line">        res[index] = win[temp_win].endtime;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="1016-Phone-Bills（日期类计算）"><a href="#1016-Phone-Bills（日期类计算）" class="headerlink" title="1016 Phone Bills（日期类计算）"></a>1016 Phone Bills（日期类计算）<span id="1016"></span></h2><h3 id="1-题目大意-6"><a href="#1-题目大意-6" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定固定格式的日期<code>mm:dd:hh:mm</code>计算各个时间的差值，以及每个时间段有不同的费率，计算总的账单费用。</p>
<h3 id="2-学习要点-1"><a href="#2-学习要点-1" class="headerlink" title="2. 学习要点"></a>2. 学习要点</h3><p>1.数据结构设计<br>因为输入是给定一个个 call 序列，所以便于存储，也以每个 call 为单位，统一放在一个数组里，按照名字、时间排序，计算的时候，只要考虑 i 和 i-1 前后两个元素是否有同一个 name 以及 status 一个为 0 一个为 1 即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> status, month, time, day, hour, minute;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.name != b.name ? a.name &lt; b.name : a.time &lt; b.time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.日期差值计算<br>直接”01:05:02:24“-”01:04:23:59“ 难以计算，每个小时还有不同的费率，所以 <strong>统一从本月 0 天 0 点开始计算</strong>，以<code>dd:hh:mm</code>格式再相减即可，隔天的情况则加上这一整天</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">billFromZero</span><span class="params">(node call, <span class="keyword">int</span> *rate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total;</span><br><span class="line">    total = rate[call.hour];  <span class="comment">//本小时的费用</span></span><br><span class="line">    total += call.minute + rate[<span class="number">24</span>] * <span class="number">60</span> * call.day;  <span class="comment">//从本月第 0 天到今天</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; call.hour; i++)</span><br><span class="line">        total += rate[i] * <span class="number">60</span>;  <span class="comment">//本天内 0 点到现在累加</span></span><br><span class="line">    <span class="keyword">return</span> total / <span class="number">100.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）"><a href="#1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）" class="headerlink" title="1018 Public Bike Management（图最短路径 Dijkstra + DFS）"></a>1018 Public Bike Management（图最短路径 Dijkstra + DFS）<span id="1018"></span></h2><p>图例经过 Dijkstra 之后的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dis[<span class="number">1</span>] = <span class="number">1</span>      pre[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;</span><br><span class="line">dis[<span class="number">2</span>] = <span class="number">1</span>      pre[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;</span><br><span class="line">dis[<span class="number">3</span>] = <span class="number">2</span>      pre[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1020-Tree-Traversals-已知后序和中序，转前序-层序"><a href="#1020-Tree-Traversals-已知后序和中序，转前序-层序" class="headerlink" title="1020 Tree Traversals (已知后序和中序，转前序/层序)"></a>1020 Tree Traversals (已知后序和中序，转前序/层序)<span id="1020"></span></h2><h3 id="1-输入格式"><a href="#1-输入格式" class="headerlink" title="1. 输入格式"></a>1. 输入格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>

<h3 id="2-分析-3"><a href="#2-分析-3" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>和手动模拟差不多，找到根节点 (pre 的第一个，post 的最后一个) -&gt; 找到左右两段的端点，分别作为左右子树 -&gt; 递归重复。关键在于递归的写法，端点的寻找。</p>
<h3 id="3-个人代码-4"><a href="#3-个人代码-4" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><code>level</code> 的作用即按照 <code>index</code> 存储，利用 2n+1 2n+2 的公式可以定位左右孩子，而索引的顺序恰好是层序遍历的顺序（具体第几层不知道）<br>转为前序遍历，只需在 pre 递归前打印 root 即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in, post, level(<span class="number">100000</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> index)</span></span>&#123;  <span class="comment">//start end 都是相对于中序序列</span></span><br><span class="line">    <span class="keyword">if</span>(start &gt; <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line">    level[index] = post[root];</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">end</span> &amp;&amp; in[i] != post[root]) i++;  <span class="comment">//找到中序 in 序列中的根节点</span></span><br><span class="line">    <span class="keyword">int</span> left_size = i-start, right_size = <span class="built_in">end</span>-i;</span><br><span class="line">    pre(root-right_size<span class="number">-1</span>, start, i<span class="number">-1</span>, index*<span class="number">2</span>+<span class="number">1</span>);  <span class="comment">//此 root 即为左孩子节点，可以确定为 index*2+1</span></span><br><span class="line">    pre(root<span class="number">-1</span>, i+<span class="number">1</span>, <span class="built_in">end</span>, index*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//找到根节点 i，左子树 start ~ i-1, 右子树 i+1 ~ end</span></span><br><span class="line">&#125;</span><br><span class="line">pre(n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1021-Deepest-Root-求树中最长的路径，DFS，连通分量"><a href="#1021-Deepest-Root-求树中最长的路径，DFS，连通分量" class="headerlink" title="1021 Deepest Root (求树中最长的路径，DFS，连通分量)"></a>1021 Deepest Root (求树中最长的路径，DFS，连通分量)<span id="1021"></span></h2><h3 id="1-题目大意-7"><a href="#1-题目大意-7" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出n个结点（1~n）之间的n条边，问是否能构成一棵树，如果不能构成则输出它有的连通分量个数；如果能构成一棵树，输出能构成最深的树的高度时，树的根结点。如果有多个，按照从小到大输出。</p>
<h3 id="2-分析-4"><a href="#2-分析-4" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>连通分量的个数：基本套路，一次 DFS 走完一个连通分量，统计循环中 DFS 开启的次数即可<br>本题关键在于，两次 DFS 即可求出所有最远端点（即所有最长路径中的所有端点）如果是一棵树的话，线段无非是两个端点，第一次 DFS 能找到一端，在这些最远端点中（可能有多个同样最远的，可能只有一个最远的）随便选一个作为起点，再来一次 DFS，即可找到另一端的最远端点。</p>
<h3 id="3-个人代码-5"><a href="#3-个人代码-5" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856" target="_blank" rel="noopener">PTA-1003</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">height</span> &gt; maxheight) &#123;</span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        temp.push_back(node);</span><br><span class="line">        maxheight = <span class="built_in">height</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">height</span> == maxheight)&#123;</span><br><span class="line">        temp.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">    visit[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[node].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[v[node][i]] == <span class="literal">false</span>)</span><br><span class="line">            dfs(v[node][i], <span class="built_in">height</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-做题-Tips"><a href="#4-做题-Tips" class="headerlink" title="4. 做题 Tips"></a>4. 做题 Tips</h3><ol>
<li>本题不用考虑权重，所以无需开一个二维数组用邻接矩阵存储<br><code>e[10010][10010]; e[a]=e[b]=weight;</code><br>只需使用邻接表，把和自己直接相连的点存起来即可<br><code>v[node][i]; resize(n+1);</code><br></li>
<li>DFS 基本套路 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dfs(<span class="keyword">int</span> node, ...)&#123;   <span class="comment">//遍历过程中顺带做其它操作</span></span><br><span class="line">    visit[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> 与本点直接相连的 i:</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">            dfs(i, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/06/djy/" data-id="ck69og06000011m6jdj9x7h86" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/02/06/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/06/djy/">djy</a>
          </li>
        
          <li>
            <a href="/2020/02/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>