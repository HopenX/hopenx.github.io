<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>djy | Hexo</title>
  <meta name="keywords" content=" PAT ">
  <meta name="description" content="djy | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="PAT-甲级 做题笔记目录0000 做题 Tips 基本经验1003 Emergency (Dijkstra 算法)1004 Counting Leaves (计算叶节点数，DFS&#x2F;BFS 树算法)1007 Maximum Subsequence Sum(最大子序列和)1010 Radix (进制转换&#x2F;二分法)1012 The Best Rank (应用问题，数据结构设计，多维度排序)1013 B">
<meta property="og:type" content="article">
<meta property="og:title" content="djy">
<meta property="og:url" content="https://hopenx.github.io/2020/02/06/djy/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="PAT-甲级 做题笔记目录0000 做题 Tips 基本经验1003 Emergency (Dijkstra 算法)1004 Counting Leaves (计算叶节点数，DFS&#x2F;BFS 树算法)1007 Maximum Subsequence Sum(最大子序列和)1010 Radix (进制转换&#x2F;二分法)1012 The Best Rank (应用问题，数据结构设计，多维度排序)1013 B">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-05T17:15:03.000Z">
<meta property="article:modified_time" content="2020-02-05T21:00:12.521Z">
<meta property="article:author" content="HopenX">
<meta property="article:tag" content="PAT">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/github.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>HopenX</span>
</div>

<div class="icon">
    
        
    
        
        <a title="github" href="https://github.com/hopenx" target="_blank">
            
                <i class="iconfont icon-github"></i>
            
        </a>
        
    
        
    
        
    
        
    
        
        <a title="instagram" href="https://www.instagram.com/xuhaopengx/" target="_blank">
            
                <i class="iconfont icon-instagram"></i>
            
        </a>
        
    
        
    
        
        <a title="weibo" href="http://weibo.com/" target="_blank">
            
                <i class="iconfont icon-weibo"></i>
            
        </a>
        
    
        
        <a title="jianshu" href="https://www.jianshu.com/u/78191b1ba408" target="_blank">
            
                <i class="iconfont icon-jianshu"></i>
            
        </a>
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/people/bo-xue-du-zhi-5" target="_blank">
            
                <i class="iconfont icon-zhihu"></i>
            
        </a>
        
    
        
    
        
    
        
    
        
        <a title="email" href="mailto:1152214965@qq.com" target="_blank">
            
                <i class="iconfont icon-email"></i>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1152214965&site=qq&menu=yes" target="_blank">
            
                <i class="iconfont icon-qq"></i>
            
        </a>
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(3)</small></div></li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">
<input type="hidden" id="yelog_site_word_count" value="8k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://hopenx.github.io/">博客</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color4">PAT</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">机器学习</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class=""
           href="/2020/02/06/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-02-06 00:04:56">2020/02/06</span>
        </a>
        
        <a  class=""
           href="/2020/02/06/djy/"
           data-tag="PAT"
           data-author="" >
            <span class="post-title" title="djy">djy</span>
            <span class="post-date" title="2020-02-06 01:15:03">2020/02/06</span>
        </a>
        
        <a  class=""
           href="/2020/02/06/ML-Study/"
           data-tag="机器学习"
           data-author="" >
            <span class="post-title" title="ML-Study">ML-Study</span>
            <span class="post-date" title="2020-02-06 04:58:39">2020/02/06</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-djy" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">djy</h1>
    
    <div class="article-meta">
        
        
        
        
        <span class="tag">
            
            <a class="color4">PAT</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-02-06 05:00:12'>2020-02-06 01:15</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:3.9k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PAT-甲级-做题笔记"><span class="toc-text">PAT-甲级 做题笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#目录"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0000-做题-Tips-基本经验"><span class="toc-text">0000 做题 Tips 基本经验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1003-Emergency-Dijkstra-算法"><span class="toc-text">1003 Emergency (Dijkstra 算法)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-题目大意"><span class="toc-text">1. 题目大意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-分析"><span class="toc-text">2. 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-个人代码"><span class="toc-text">3. 个人代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-学习要点"><span class="toc-text">4. 学习要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1004-Counting-Leaves-dfs-bfs-树算法"><span class="toc-text">1004 Counting Leaves (dfs&#x2F;bfs 树算法)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-题目大意-1"><span class="toc-text">1. 题目大意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-坑"><span class="toc-text">2. 坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-个人代码-1"><span class="toc-text">3. 个人代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-正确方法"><span class="toc-text">4. 正确方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1007-Maximum-Subsequence-Sum-最大子序列和"><span class="toc-text">1007 Maximum Subsequence Sum (最大子序列和)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-题目大意-2"><span class="toc-text">1.题目大意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-分析-1"><span class="toc-text">2.分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-个人代码-2"><span class="toc-text">3. 个人代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-类似题"><span class="toc-text">4. 类似题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1010-Radix-进制转换-二分法"><span class="toc-text">1010 Radix (进制转换&#x2F;二分法)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-学习要点-1"><span class="toc-text">4. 学习要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1012-The-Best-Rank-数据结构设计-多维度排序"><span class="toc-text">1012 The Best Rank (数据结构设计&#x2F;多维度排序)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-题目大意-3"><span class="toc-text">1. 题目大意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-个人代码"><span class="toc-text">2. 个人代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-学习要点"><span class="toc-text">3. 学习要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）"><span class="toc-text">1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-题目大意-4"><span class="toc-text">1. 题目大意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-分析-2"><span class="toc-text">2. 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-个人代码-3"><span class="toc-text">3. 个人代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1014-Reversible-Primes（队列应用-排队问题）"><span class="toc-text">1014 Reversible Primes（队列应用 排队问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-题目大意-5"><span class="toc-text">1. 题目大意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-学习要点"><span class="toc-text">2. 学习要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1016-Phone-Bills（日期类计算）"><span class="toc-text">1016 Phone Bills（日期类计算）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-题目大意-6"><span class="toc-text">1. 题目大意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-学习要点-1"><span class="toc-text">2. 学习要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）"><span class="toc-text">1018 Public Bike Management（图最短路径 Dijkstra + DFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1020-Tree-Traversals-已知后序和中序，转前序-层序"><span class="toc-text">1020 Tree Traversals (已知后序和中序，转前序&#x2F;层序)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-输入格式"><span class="toc-text">1. 输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-分析-3"><span class="toc-text">2. 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-个人代码-4"><span class="toc-text">3. 个人代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1021-Deepest-Root-求树中最长的路径，DFS，连通分量"><span class="toc-text">1021 Deepest Root (求树中最长的路径，DFS，连通分量)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-题目大意-7"><span class="toc-text">1. 题目大意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-分析-4"><span class="toc-text">2. 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-个人代码-5"><span class="toc-text">3. 个人代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-做题-Tips"><span class="toc-text">4. 做题 Tips</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PAT-甲级-做题笔记"><a href="#PAT-甲级-做题笔记" class="headerlink" title="PAT-甲级 做题笔记"></a>PAT-甲级 做题笔记</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>0000 <a href="#0000">做题 Tips 基本经验</a><br>1003 <a href="#1003">Emergency (Dijkstra 算法)</a><br>1004 <a href="#1004">Counting Leaves (计算叶节点数，DFS/BFS 树算法)</a><br>1007 <a href="#1007">Maximum Subsequence Sum(最大子序列和)</a><br>1010 <a href="#1010">Radix (进制转换/二分法)</a><br>1012 <a href="#1012">The Best Rank (应用问题，数据结构设计，多维度排序)</a><br>1013 <a href="#1013">Battle Over Cities (图的遍历，统计强连通分量的个数，DFS)</a><br>1014 <a href="#1014">Waiting in Line (队列应用，排队问题)</a><br>1015 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805495863296000" target="_blank" rel="noopener">Reversible Primes (进制转换+判断素数：可取用函数)</a><br>1016 <a href="#1016">Phone Bills (日期类计算)</a><br>1018 <a href="#1018">Public Bike Management (图最短路径 Dijkstra + DFS)</a><br>1020 <a href="#1020">Tree Traversals (已知后序和中序，转前序/层序)</a><br>1021 <a href="#1021">Deepest Root (求树中最长的路径，DFS，连通分量)</a></p>
<hr>
<h2 id="0000-做题-Tips-基本经验"><a href="#0000-做题-Tips-基本经验" class="headerlink" title="0000 做题 Tips 基本经验"></a>0000 做题 Tips 基本经验<span id="0000"></span></h2><ol>
<li><p>最后千万别栽在头文件上，比如 reverse() 属于 &lt; algorithm&gt;</p>
</li>
<li><p>输出多行的时候，最后有一个多余的空行也没问题<br>比如使用 <code>cout &lt;&lt; a &lt;&lt; endl</code> 三次，样例输出：</p>
<pre><code> 3
 4
 5</code></pre><p> 实际输出：最后有一个多余空行没关系</p>
<pre><code> 3
 4
 5
</code></pre></li>
</ol>
<hr>
<h2 id="1003-Emergency-Dijkstra-算法"><a href="#1003-Emergency-Dijkstra-算法" class="headerlink" title="1003 Emergency (Dijkstra 算法)"></a>1003 Emergency (Dijkstra 算法)<span id="1003"></span></h2><h3 id="1-题目大意"><a href="#1-题目大意" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>n个城市m条路，每个城市有救援小组，所有的边的边权已知。给定起点和终点，求从起点到终点的最短路径条数以及最短路径上的救援小组数目之和。如果有多条就输出点权（城市救援小组数目）最大的那个</p>
<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>用一遍Dijkstra算法～救援小组个数相当于点权，用Dijkstra求边权最小的最短路径的条数，以及这些最短路径中点权最大的值～dis[i]表示从出发点到i结点最短路径的路径长度，num[i]表示从出发点到i结点最短路径的条数，w[i]表示从出发点到i点救援队的数目之和～当判定dis[u] + e[u][v] &lt; dis[v]的时候，不仅仅要更新dis[v]，还要更新num[v] = num[u], w[v] = weight[v] + w[u]; 如果dis[u] + e[u][v] == dis[v]，还要更新num[v] += num[u]，而且判断一下是否权重w[v]更小，如果更小了就更新w[v] = weight[v] + w[u]</p>
<h3 id="3-个人代码"><a href="#3-个人代码" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">PTA-1003</a></p>
<h3 id="4-学习要点"><a href="#4-学习要点" class="headerlink" title="4. 学习要点"></a>4. 学习要点</h3><blockquote>
<p>1.真正理解单源最短路径，每一次选择的 dis 都是相对于源点的最短路径<br>2.大数组要设为全局变量<br>3.外层循环 i：n 次循环，每次访问一个新点，保证 n 个点全访问到；内层循环 j：继续寻找还未访问的点，找 dis 最小的访问；内层循环 k：更新所有能够更新的 dis</p>
</blockquote>
<hr>
<h2 id="1004-Counting-Leaves-dfs-bfs-树算法"><a href="#1004-Counting-Leaves-dfs-bfs-树算法" class="headerlink" title="1004 Counting Leaves (dfs/bfs 树算法)"></a>1004 Counting Leaves (dfs/bfs 树算法)<span id="1004"></span></h2><h3 id="1-题目大意-1"><a href="#1-题目大意-1" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出一棵树，问每一层各有多少个叶子结点</p>
<h3 id="2-坑"><a href="#2-坑" class="headerlink" title="2. 坑"></a>2. 坑</h3><pre><code>list[tmp].lev = list[fa].lev + 1;  //出问题,不一定按照顺序输入</code></pre><p>有可能先 03 后 01，fa 的 lev 还没确定，不能给孩子节点 +1</p>
<pre><code>3 2
03 1 02
01 1 03</code></pre><h3 id="3-个人代码-1"><a href="#3-个人代码-1" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184" target="_blank" rel="noopener">PTA-1004</a></p>
<h3 id="4-正确方法"><a href="#4-正确方法" class="headerlink" title="4. 正确方法"></a>4. 正确方法</h3><pre><code class="C++">void dfs(int fa){
    for (auto &amp;ch : list[fa].v) {
        list[ch].lev = list[fa].lev + 1;
        dfs(ch);
    }
}
dfs(1);   //通过 DFS 一层层给叶子节点 lev+1</code></pre>
<hr>
<h2 id="1007-Maximum-Subsequence-Sum-最大子序列和"><a href="#1007-Maximum-Subsequence-Sum-最大子序列和" class="headerlink" title="1007 Maximum Subsequence Sum (最大子序列和)"></a>1007 Maximum Subsequence Sum (最大子序列和)<span id="1007"></span></h2><h3 id="1-题目大意-2"><a href="#1-题目大意-2" class="headerlink" title="1.题目大意"></a>1.题目大意</h3><p>求最大连续子序列和，输出最大的和以及这个子序列的开始值和结束值。如果所有数都小于0，那么认为最大的和为0，并且输出首尾元素</p>
<h3 id="2-分析-1"><a href="#2-分析-1" class="headerlink" title="2.分析"></a>2.分析</h3><p>本质上是<strong>动态规划</strong>的思想，数组为<code>vec[]</code>，设<code>dp[i]</code> 是以<code>vec[i]</code>结尾的子数组的最大和，对于元素<code>vec[i+1]</code>, 它有两种选择：<code>vec[i+1]</code>接着前面的子数组构成最大和; <code>vec[i+1]</code>自己单独构成子数组。则<code>dp[i+1] = max{dp[i]+vec[i+1],  vec[i+1]}</code></p>
<p>简化则用一个 temp_sum 和一个 temp_first 解决，真正最大和为 sum，起始点为 first 和 last，建立局部和全局的关系。如果 <code>temp_sum &lt; 0</code>, 说明目前这一段对后续的序列和已经没有加成作用，可以舍弃另立门户，令<code>temp_sum = 0</code></p>
<h3 id="3-个人代码-2"><a href="#3-个人代码-2" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><pre><code class="c++">//初始值设置容易坑：sum要为-1 才能开始
int sum=-1, temp_sum=0, first=0, last=k-1, temp_first=0;
for (int j = 0; j &lt; k; ++j) {
    temp_sum += a[j];
    if(temp_sum &lt; 0){
        temp_sum = 0;
        temp_first = j+1;   //本段已经可以舍弃，开始新一段
    } else if(temp_sum &gt; sum){
        sum = temp_sum;
        first = temp_first;
        last = j;
    }
}
if(sum &lt; 0) sum = 0;  //如果全负则为 0，根据题目要求不要漏情况</code></pre>
<h3 id="4-类似题"><a href="#4-类似题" class="headerlink" title="4. 类似题"></a>4. 类似题</h3><p><a href="https://www.cnblogs.com/grandyang/p/4480780.html" target="_blank" rel="noopener">最长无重复子串</a></p>
<hr>
<h2 id="1010-Radix-进制转换-二分法"><a href="#1010-Radix-进制转换-二分法" class="headerlink" title="1010 Radix (进制转换/二分法)"></a>1010 Radix (进制转换/二分法)<span id="1010"></span></h2><p>###1. 题目大意<br>给定两个相等数，已知一个数的进制，求另外一个数的进制（radix-&gt;基数）</p>
<p>###2. 分析<br>通用函数<code>cal(string str, int radix)</code>把任意进制的数转换为 10 进制数<br>在使用搜索遍历，找到另一个数对应的进制</p>
<p>###3.个人代码<br><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536" target="_blank" rel="noopener">PTA-1010</a></p>
<p>转换函数</p>
<pre><code class="c++">long long cal(string str, long long radix){
    long long target=0, bak = 1;
    reverse(str.begin(), str.end());
    for (char c : str) {
        if(isdigit(c))
            target += (c - &#39;0&#39;) * bak;
        else
            target += (c - &#39;a&#39; + 10) * bak;
        bak *= radix;  //也可以使用&lt;cmath&gt;的 pow()函数
    }
    return target;
}</code></pre>
<p>搜索函数</p>
<pre><code class="c++">long long find_radix(string str, long long tar){
    char c = *max_element(str.begin(), str.end());  //最大字母
    //进制至少比最大字母要大
    long long low = isdigit(c) ? c-&#39;0&#39; : c-&#39;a&#39;+10;
    low += 1;  //必须要加一,至少多1
    long long high = max(low, tar);  //进制最大不会大于目标 tar
    while (low &lt;= high){
        long long mid = (low+high)/2;
        long long tmp = cal(str, mid);
        if(tmp &lt; 0 || tmp &gt; tar) high = mid - 1;  //小于 0 也是进制太大
        else if(tmp == tar) return mid;
        else low = mid + 1;
    }
    return -1;
}</code></pre>
<h3 id="4-学习要点-1"><a href="#4-学习要点-1" class="headerlink" title="4. 学习要点"></a>4. 学习要点</h3><blockquote>
<ol>
<li>进制转换这种大数字的乘法很容易溢出，必须要用 <code>long long</code></li>
<li>暴力搜索（从 2 到 ∞ 容易超时）最好用二分法，并且限定范围：最小是 <code>low</code> 至少是最大的那个字母+1，比如 fff 最少是 15+1=16 进制，最大是<code>high</code>不超过目标 <code>tar</code></li>
<li>可以使用反向迭代器 <code>it = n.rbegin(); it != n.rend()</code>代替<code>reverse()</code></li>
</ol>
</blockquote>
<hr>
<h2 id="1012-The-Best-Rank-数据结构设计-多维度排序"><a href="#1012-The-Best-Rank-数据结构设计-多维度排序" class="headerlink" title="1012 The Best Rank (数据结构设计/多维度排序)"></a>1012 The Best Rank (数据结构设计/多维度排序)<span id="1012"></span></h2><h3 id="1-题目大意-3"><a href="#1-题目大意-3" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>找出每个人自己最优势的科目，也就是单独排名最好的科目，优先级 A &gt; C &gt; M &gt; E</p>
<ul>
<li>Sample Input:<pre><code>5 6
310101 98 85 88
310102 70 95 88
310103 82 87 94
310104 91 91 91
310105 85 90 90
310101
310102
310103
310104
310105
999999</code></pre></li>
<li>Sample Output:<pre><code>1 C
1 M
1 E
1 A
3 A
N/A</code></pre></li>
</ul>
<h3 id="2-个人代码"><a href="#2-个人代码" class="headerlink" title="2. 个人代码"></a>2. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480" target="_blank" rel="noopener">PTA-1012</a></p>
<h3 id="3-学习要点"><a href="#3-学习要点" class="headerlink" title="3. 学习要点"></a>3. 学习要点</h3><p>数据结构设计</p>
<pre><code class="c++">struct node{
    //一定要用数组形式，避免过多变量 int c, m, e, c_r, m_r, e_r, a_r;
    int id, best;
    int score[4], rank[4];
}stu[2001];  //输入学生序列，非学号排序

int exist[1000000], flag=-1; //exist 至少 &gt;0, 顺便建立 id-输入序号 映射

//使用 flag 配置作用，避免写过多重复的 cmp 函数
bool cmp(node &amp;a, node &amp;b){ return a.score[flag] &gt; b.score[flag];}</code></pre>
<p>输入后，利用<code>exist[stu[k].id] = k + 1; k++</code> 依次建立映射<br>输出时，利用<code>cin &gt;&gt; tmp; ex = exist[tmp]</code>和<code>stu[ex-1]</code>实现映射，无需 find<br>处理时，使用<code>sort(stu, stu+n, cmp)</code> 循环 <code>flag++</code>，实现分学科多次排序，确定 <code>rank[]</code></p>
<hr>
<h2 id="1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）"><a href="#1013-Battle-Over-Cities（图的遍历，统计强连通分量的个数，dfs）" class="headerlink" title="1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）"></a>1013 Battle Over Cities（图的遍历，统计强连通分量的个数，dfs）<span id="1013"></span></h2><h3 id="1-题目大意-4"><a href="#1-题目大意-4" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出n个城市之间有相互连接的m条道路，当删除一个城市和其连接的道路的时候，问其他几个剩余的城市至少要添加多少个路线，才能让它们重新变为连通图</p>
<h3 id="2-分析-2"><a href="#2-分析-2" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>n 连通分量，最少需要 n-1 条边相连，所以本题实质就是求「去除某点及其相连的边」后，剩余的「连通分量个数」是一个图算法，需要用图的遍历来解决 (DFS)</p>
<blockquote>
<p>求连通分量依据：一次 <code>dfs()</code>走到底，可以访问完一个连通分量</p>
</blockquote>
<p>数据结构：</p>
<blockquote>
<p>涉及图的遍历，要考虑 <code>visit[]</code>数组<br>图的路径存储，使用二维矩阵</p>
</blockquote>
<h3 id="3-个人代码-3"><a href="#3-个人代码-3" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">PTA-1013</a></p>
<pre><code class="c++">for (int i = 0; i &lt; k; ++i) {
        int cur, cnt=0;
        cin &gt;&gt; cur;
        fill(visited, visited+n, false);
        visited[cur] = true;  //相当于把本点去除
        for (int j = 1; j &lt;= n; ++j) {  //依次计算所有连通分量，而非从本点出发
            if(!visited[j]){
                dfs(j);
                cnt++;
            }
        }
        cout &lt;&lt; cnt-1 &lt;&lt; endl;
    }</code></pre>
<pre><code class="c++">void dfs(int st){   //只用来 visit，不负责计数
    visited[st] = true;
    for (int i = 0; i &lt;= n; ++i)
        if(!visited[i] &amp;&amp; e[st][i]){   //未访问且有路
            dfs(i);
        }
}</code></pre>
<hr>
<h2 id="1014-Reversible-Primes（队列应用-排队问题）"><a href="#1014-Reversible-Primes（队列应用-排队问题）" class="headerlink" title="1014 Reversible Primes（队列应用 排队问题）"></a>1014 Reversible Primes（队列应用 排队问题）<span id="1014"></span></h2><h3 id="1-题目大意-5"><a href="#1-题目大意-5" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>n个窗口，每个窗口可以排队m人。有k位用户需要服务，给出了每位用户需要的minute数，所有客户在8点开始服务，如果有窗口还没排满就入队，否则就在黄线外等候。如果有某一列有一个用户走了服务完毕了，黄线外的人就进来一个。如果同时就选窗口数小的。求q个人的服务结束时间。<br>如果一个客户在17:00以及以后还没有开始服务（此处不是结束服务是开始17:00）就不再服务输出sorry；如果这个服务已经开始了，无论时间多长都要等他服务完毕。</p>
<h3 id="2-学习要点"><a href="#2-学习要点" class="headerlink" title="2. 学习要点"></a>2. 学习要点</h3><p>面对此类题目，总想按照 timeline 每分每秒去决策，其实队列的问题用队列解决。</p>
<p>以每个窗口为单位设计结构体，<code>poptime</code> 用于刚入黄线的人决策，<code>endtime</code> 用于已经在队内的人是否会 sorry 决策，<code>q</code> 表示本队列内排队情况。</p>
<p>给定客户序列，则以每一个客户为循环单位<code>(index++)</code>，队列有一个进就会有一个出，每次变动一个单位，更新各个队列的<code>poptime endtime q</code>等变量。</p>
<pre><code class="c++">struct node {
    int poptime, endtime;  //队首的人出队（结束）的时间, 队尾的人结束的时间
    queue&lt;int&gt; q;
};

int index = 1;
    //第 1 步：n*m 个客户先抢占黄线内, 直接瞬间涌入，不存在选择
    for (int i = 1; i &lt;= cap; ++i) {    //看做行和列，先抢第一行
        for (int j = 1; j &lt;= n; ++j) {
            if(index &lt;= k){
                win[j].q.push(time[index]);
                if(win[j].endtime &gt;= 540)
                    sorry[index] = true;
                win[j].endtime += time[index];
                if(i == 1)  //对于第一行，出队时间即本队结束时间，做一个初始化
                    win[j].poptime = win[j].endtime;
                res[index] = win[j].endtime;  //刚进来的，自己是队尾，队伍结束就是自己结束
                index++;
            }
        }
    }

    //第 2 步：后续的客户
    while (index &lt;= k){   //while一次循环表示一个客户的选择
        int temp_min = win[1].poptime, temp_win = 1;  //初始化
        for (int i = 2; i &lt;= n; ++i) {   //找最早出队的
            if(win[i].poptime &lt; temp_min){
                temp_win = i;
                temp_min = win[i].poptime;
            }
        }
        win[temp_win].q.pop();
        win[temp_win].q.push(time[index]);
        win[temp_win].poptime += win[temp_win].q.front(); //更新：最前面那个人完成的时间就是出队时间
        if(win[temp_win].endtime &gt;= 540)  //endtime 还未更新，是看的前一个人的完成时间，是否超时
            sorry[index] = true;
        win[temp_win].endtime += time[index];  //更新：刚进来的这个人的完成时间就是本队的完成时间
        res[index] = win[temp_win].endtime;
        index++;
    }</code></pre>
<hr>
<h2 id="1016-Phone-Bills（日期类计算）"><a href="#1016-Phone-Bills（日期类计算）" class="headerlink" title="1016 Phone Bills（日期类计算）"></a>1016 Phone Bills（日期类计算）<span id="1016"></span></h2><h3 id="1-题目大意-6"><a href="#1-题目大意-6" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给定固定格式的日期<code>mm:dd:hh:mm</code>计算各个时间的差值，以及每个时间段有不同的费率，计算总的账单费用。</p>
<h3 id="2-学习要点-1"><a href="#2-学习要点-1" class="headerlink" title="2. 学习要点"></a>2. 学习要点</h3><p>1.数据结构设计<br>因为输入是给定一个个 call 序列，所以便于存储，也以每个 call 为单位，统一放在一个数组里，按照名字、时间排序，计算的时候，只要考虑 i 和 i-1 前后两个元素是否有同一个 name 以及 status 一个为 0 一个为 1 即可。</p>
<pre><code class="c++">struct node {
    string name;
    int status, month, time, day, hour, minute;
};

bool cmp(node a, node b) {
    return a.name != b.name ? a.name &lt; b.name : a.time &lt; b.time;
}</code></pre>
<p>2.日期差值计算<br>直接”01:05:02:24“-”01:04:23:59“ 难以计算，每个小时还有不同的费率，所以 <strong>统一从本月 0 天 0 点开始计算</strong>，以<code>dd:hh:mm</code>格式再相减即可，隔天的情况则加上这一整天</p>
<pre><code class="c++">double billFromZero(node call, int *rate) {
    double total;
    total = rate[call.hour];  //本小时的费用
    total += call.minute + rate[24] * 60 * call.day;  //从本月第 0 天到今天
    for (int i = 0; i &lt; call.hour; i++)
        total += rate[i] * 60;  //本天内 0 点到现在累加
    return total / 100.0;
}</code></pre>
<hr>
<h2 id="1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）"><a href="#1018-Public-Bike-Management（图最短路径-Dijkstra-DFS）" class="headerlink" title="1018 Public Bike Management（图最短路径 Dijkstra + DFS）"></a>1018 Public Bike Management（图最短路径 Dijkstra + DFS）<span id="1018"></span></h2><p>图例经过 Dijkstra 之后的结果</p>
<pre><code class="c++">dis[1] = 1      pre[1] = {0}
dis[2] = 1      pre[2] = {0}
dis[3] = 2      pre[3] = {1, 2}</code></pre>
<hr>
<h2 id="1020-Tree-Traversals-已知后序和中序，转前序-层序"><a href="#1020-Tree-Traversals-已知后序和中序，转前序-层序" class="headerlink" title="1020 Tree Traversals (已知后序和中序，转前序/层序)"></a>1020 Tree Traversals (已知后序和中序，转前序/层序)<span id="1020"></span></h2><h3 id="1-输入格式"><a href="#1-输入格式" class="headerlink" title="1. 输入格式"></a>1. 输入格式</h3><pre><code>7
2 3 1 5 7 6 4
1 2 3 4 5 6 7</code></pre><h3 id="2-分析-3"><a href="#2-分析-3" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>和手动模拟差不多，找到根节点 (pre 的第一个，post 的最后一个) -&gt; 找到左右两段的端点，分别作为左右子树 -&gt; 递归重复。关键在于递归的写法，端点的寻找。</p>
<h3 id="3-个人代码-4"><a href="#3-个人代码-4" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><code>level</code> 的作用即按照 <code>index</code> 存储，利用 2n+1 2n+2 的公式可以定位左右孩子，而索引的顺序恰好是层序遍历的顺序（具体第几层不知道）<br>转为前序遍历，只需在 pre 递归前打印 root 即可</p>
<pre><code class="c++">vector&lt;int&gt; in, post, level(100000, -1);

void pre(int root, int start, int end, int index){  //start end 都是相对于中序序列
    if(start &gt; end) return;
    level[index] = post[root];
    int i = start;
    while (i &lt; end &amp;&amp; in[i] != post[root]) i++;  //找到中序 in 序列中的根节点
    int left_size = i-start, right_size = end-i;
    pre(root-right_size-1, start, i-1, index*2+1);  //此 root 即为左孩子节点，可以确定为 index*2+1
    pre(root-1, i+1, end, index*2+2);
    //找到根节点 i，左子树 start ~ i-1, 右子树 i+1 ~ end
}
pre(n-1, 0, n-1, 0);</code></pre>
<hr>
<h2 id="1021-Deepest-Root-求树中最长的路径，DFS，连通分量"><a href="#1021-Deepest-Root-求树中最长的路径，DFS，连通分量" class="headerlink" title="1021 Deepest Root (求树中最长的路径，DFS，连通分量)"></a>1021 Deepest Root (求树中最长的路径，DFS，连通分量)<span id="1021"></span></h2><h3 id="1-题目大意-7"><a href="#1-题目大意-7" class="headerlink" title="1. 题目大意"></a>1. 题目大意</h3><p>给出n个结点（1~n）之间的n条边，问是否能构成一棵树，如果不能构成则输出它有的连通分量个数；如果能构成一棵树，输出能构成最深的树的高度时，树的根结点。如果有多个，按照从小到大输出。</p>
<h3 id="2-分析-4"><a href="#2-分析-4" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>连通分量的个数：基本套路，一次 DFS 走完一个连通分量，统计循环中 DFS 开启的次数即可<br>本题关键在于，两次 DFS 即可求出所有最远端点（即所有最长路径中的所有端点）如果是一棵树的话，线段无非是两个端点，第一次 DFS 能找到一端，在这些最远端点中（可能有多个同样最远的，可能只有一个最远的）随便选一个作为起点，再来一次 DFS，即可找到另一端的最远端点。</p>
<h3 id="3-个人代码-5"><a href="#3-个人代码-5" class="headerlink" title="3. 个人代码"></a>3. 个人代码</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856" target="_blank" rel="noopener">PTA-1003</a></p>
<pre><code class="c++">void dfs(int node, int height) {
    if(height &gt; maxheight) {
        temp.clear();
        temp.push_back(node);
        maxheight = height;
    } else if(height == maxheight){
        temp.push_back(node);
    }
    visit[node] = true;
    for(int i = 0; i &lt; v[node].size(); i++) {
        if(visit[v[node][i]] == false)
            dfs(v[node][i], height + 1);
    }</code></pre>
<h3 id="4-做题-Tips"><a href="#4-做题-Tips" class="headerlink" title="4. 做题 Tips"></a>4. 做题 Tips</h3><ol>
<li>本题不用考虑权重，所以无需开一个二维数组用邻接矩阵存储<br><code>e[10010][10010]; e[a]=e[b]=weight;</code><br>只需使用邻接表，把和自己直接相连的点存起来即可<br><code>v[node][i]; resize(n+1);</code><br></li>
<li>DFS 基本套路<pre><code class="c++"> dfs(int node, ...){   //遍历过程中顺带做其它操作
     visit[node] = true;
     for 与本点直接相连的 i:
         if(!visit[i])
             dfs(i, ...)
 }</code></pre>
</li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎交流 1152214965@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>djy</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">3.9k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="HopenX">HopenX</a></p>
    <p><span class="copy-title">发布时间:</span>2020-02-06, 01:15:03</p>
    <p><span class="copy-title">最后更新:</span>2020-02-06, 05:00:12</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/02/06/djy/" title="djy">https://hopenx.github.io/2020/02/06/djy/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2020 HopenX</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#PAT','#机器学习',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
    .post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
